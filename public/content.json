{"meta":{"title":"Jimmy's Blog","subtitle":"专注于各种技术干货的收集与分享","description":"大三学生，热爱技术","author":"Jimmy","url":"http://jimmy9876.top"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-10-16T07:42:44.681Z","updated":"2017-10-16T07:25:54.733Z","comments":false,"path":"/404.html","permalink":"http://jimmy9876.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2017-10-17T04:25:22.920Z","updated":"2017-10-17T04:25:22.920Z","comments":false,"path":"about/index.html","permalink":"http://jimmy9876.top/about/index.html","excerpt":"","text":"我是 Jimmy目前就读于南京邮电大学是一名应届生热爱前端后端各种技术QQ: 370555337E-mail: aimpeter@163.com"},{"title":"书单","date":"2017-10-16T07:43:14.550Z","updated":"2017-10-16T07:25:54.734Z","comments":false,"path":"books/index.html","permalink":"http://jimmy9876.top/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-16T07:43:14.559Z","updated":"2017-10-16T07:25:54.734Z","comments":false,"path":"categories/index.html","permalink":"http://jimmy9876.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-10-16T07:43:14.568Z","updated":"2017-10-16T07:25:54.735Z","comments":true,"path":"links/index.html","permalink":"http://jimmy9876.top/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2017-10-16T07:43:17.929Z","updated":"2017-10-16T07:25:54.735Z","comments":false,"path":"repository/index.html","permalink":"http://jimmy9876.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-16T07:41:29.748Z","updated":"2017-10-16T07:41:29.748Z","comments":false,"path":"tags/index.html","permalink":"http://jimmy9876.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"阿里云vps搭建自己的hexo博客","slug":"阿里云vps搭建自己的hexo博客","date":"2017-06-16T11:44:20.000Z","updated":"2017-10-16T07:16:33.214Z","comments":true,"path":"2017/06/16/阿里云vps搭建自己的hexo博客/","link":"","permalink":"http://jimmy9876.top/2017/06/16/阿里云vps搭建自己的hexo博客/","excerpt":"阿里云vps搭建自己的hexo博客","text":"阿里云vps搭建自己的hexo博客 1. 博客的架构先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。不然只跟着步骤过了一遍，却不知道为什么这么做。首先看这张架构图：整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。 2. 整个搭建流程第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站第三部分: 使用Git自动化部署发布博客 3. 服务器环境搭建 3-1.安装Git和NodeJS (CentOS 环境)123yum install git#安装NodeJScurl --silent --location https://rpm.nodesource.com/setup_5.x | bash -NodeJS 安装可以参考： Linux安装NodeJS 3-2. 创建git用户123adduser gitchmod 740 /etc/sudoersvim /etc/sudoers找到以下内容12## Allow root to run any commands anywhereroot ALL=(ALL) ALL在下面添加一行1git ALL=(ALL) ALL保存退出后改回权限1chmod 400 /etc/sudoers随后设置Git用户的密码，12#需要root权限sudo passwd git切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys文件，并赋予相应的权限123456su gitmkdir ~/.sshvim ~/.ssh/authorized_keys#然后将电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.ssh然后就可以执行ssh 命令测试是否可以免密登录1ssh -v git@SERVER至此，Git用户添加完成 3-3. Nginx安装和配置我是用的是lnmp 一键安装包，nginx安装教程一大堆，就不再叙述。主要看nginx配置。找到nginx的配置文件，修改配置如下：1234567891011121314151617181920212223242526272829server&#123; listen 80; #listen [::]:80; server_name www.seekbetter.me seekbetter.me; index index.html index.htm index.php default.html default.htm default.php; #这里要改成网站的根目录 root /path/to/www; include other.conf; #error_page 404 /404.html; location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$ &#123; access_log off; expires 1d; &#125; location ~ .*\\.(js|css|txt|xml)?$ &#123; access_log off; expires 12h; &#125; location / &#123; try_files $uri $uri/ =404; &#125; access_log /home/wwwlogs/blog.log access;&#125; 4. 本地Hexo程序 4-1：初始化Hexo博客首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行1sudo npm install -g hexo-cli然后初始化Hexo程序12cd ~/Documents/codehexo init blog等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。hexo-deployer-git帮助文档hexo-server帮助文档123cd blognpm install hexo-deployer-git --savenpm install hero-server 4-2. 生成自己的第一篇文章 hello world !使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。12hexo new &quot;hello Hexo&quot;vim sources/_posts/hello-hexo.md编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server：12hexo ghexo server现在便可以打开浏览器访问 http://localhost:4000 来查看我们的博客了！ 5. 自动化部署 5-1：服务器上建立git裸库创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权一定要加 --bare，这样才是一个裸库。123su gitcd ~git init --bare blog.git 5-2. 使用 git-hooks 同步网站根目录在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，新建post-receive文件。1234vim ~/blog.git/hooks/post-receive#!/bin/shgit --work-tree=/path/to/www --git-dir=~/blog.git checkout -f保存后，要赋予这个文件可执行权限1chmod +x post-receive 5-3. 配置_config.yml,完成自动化部署然后打开 _config.yml, 找到 deploy12345deploy: type: git repo: git@SERVER:/home/git/blog.git //&lt;repository url&gt; branch: master //这里填写分支 [branch] message: 提交的信息 //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;)保存后，尝试将我们刚才写的&quot;hello hexo&quot;部署到服务器12hexo cleanhexo generate --deploy访问服务器地址，就可以看到我们写的文章&quot;Hello hexo&quot;,以后写文章只需要：123hexo new &quot;Blog article name&quot;···写文章hexo clean &amp;&amp; hexo generate --deploy博客就更新咯！~ 参考资料：使用 Git Hook 自动部署 Hexo 到个人 VPSHexo 文档","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jimmy9876.top/tags/hexo/"}]},{"title":"让你的hexo博客支持LaTex数学公式","slug":"让你的hexo博客支持LaTex数学公式","date":"2017-06-11T08:21:20.000Z","updated":"2017-10-16T08:02:07.580Z","comments":true,"path":"2017/06/11/让你的hexo博客支持LaTex数学公式/","link":"","permalink":"http://jimmy9876.top/2017/06/11/让你的hexo博客支持LaTex数学公式/","excerpt":"利用MathJax来渲染LaTeX数学公式","text":"利用MathJax来渲染LaTeX数学公式经过一番google之后，发现有位高手已经写好了一个自动部署MathJax的hexo插件http://catx.me/2014/03/09/hexo-mathjax-plugin/安装方式也很简单，在你的博客文件夹下执行12npm install hexo-math --savehexo math install这里npm如果缓慢，请自行换成淘宝镜像源关于淘宝镜像源，在之前文章中有提到，请自行查阅然后在新建的博文中写上一个查看LaTeX效果123456\\begin&#123;align&#125;\\theta\\_0 &amp; := \\theta\\_0 - \\alpha\\frac&#123;\\partial&#125;&#123;\\partial\\theta\\_0&#125;J(\\theta\\_0,\\theta\\_1) \\\\\\\\&amp; = \\theta\\_0 - \\alpha\\frac&#123;\\partial&#125;&#123;\\partial\\theta\\_0&#125; \\frac&#123;1&#125;&#123;2m&#125; \\sum\\_&#123;i=1&#125;^&#123;m&#125;(h\\_\\theta(x^&#123;(i)&#125;) - y^&#123;(i)&#125;)^2 \\\\\\\\&amp; = \\theta\\_0 - (\\alpha \\frac&#123;1&#125;&#123;2m&#125; \\* 2 \\* \\sum\\_&#123;i=1&#125;^&#123;m&#125;(h\\_\\theta(x^&#123;(i)&#125;) - y^&#123;(i)&#125;)) \\* \\frac&#123;\\partial&#125;&#123;\\partial\\theta\\_0&#125;(h\\_\\theta(x^&#123;(i)&#125;) - y^&#123;(i)&#125;) \\\\\\\\&amp; = \\theta\\_0 - \\frac&#123;\\alpha&#125;&#123;m&#125; * \\sum\\_&#123;i=1&#125;^&#123;m&#125;(h\\_\\theta(x^&#123;(i)&#125;) - y^&#123;(i)&#125;)\\end&#123;align&#125;Rm×n=Um×mSm×nVn×n′R_{m \\times n} = U_{m \\times m} S_{m \\times n} V_{n \\times n}&#x27;R​m×n​​=U​m×m​​S​m×n​​V​n×n​′​​嗯，发现一切显示完美…","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jimmy9876.top/tags/hexo/"}]},{"title":"软件测试习题（更新ing）","slug":"软件测试习题（更新ing）","date":"2017-06-11T06:21:57.000Z","updated":"2017-10-16T07:16:33.214Z","comments":true,"path":"2017/06/11/软件测试习题（更新ing）/","link":"","permalink":"http://jimmy9876.top/2017/06/11/软件测试习题（更新ing）/","excerpt":"软件测试复习软件测试复习题","text":"软件测试复习软件测试复习题 软件测试复习 判断题1a、软件测试的目的仅仅是尽可能多的找出软件中的缺陷（ ）1b、没有检测出错误的测试用例是低质量的测试用例（ ）2、自适应随机测试的错误检测效率高于随机测试（ ）3a、回归测试是由最终用户来实施的（ ）3b、回归测试中，必须运行前次测试中的所有测试用例（ ）4、需求规格说明书确定后，软件实现的额外功能越多越好（ ）5a、大多数软件缺陷是在程序编码阶段导致的（ ）5b、编码开始前的活动不会导致软件缺陷（ ）5c、大多数软件缺陷是在需求分析阶段导致的（ ）6a、白盒测试中，满足判定覆盖标准的测试用例集，其错误检测能力强于满足条件覆盖标准的测试用例集（ ）6b、白盒测试中，满足判定覆盖标准的测试用例集，其对逻辑表达式的覆盖能力强于满足条件覆盖标准的测试用例集（ ）7a、自底向上集成需要测试员编写驱动模块（ ）7b、自底向上集成需要测试员编写桩模块（ ）7c、自顶向下集成需要测试员编写驱动模块（ ）7d、自顶向下集成需要测试员编写桩模块（ ）8、负载测试是验证要检验的系统的能力最高能达到什么程度（ ）9、测试人员要坚持原则，缺陷未修复完坚决不予通过（ ）10、发现错误多的模块，残留在模块中的错误也多（ ）11a、编码完成之前测试人员不需要提交任何工作（ ）11b、编码完成之前测试人员不需要开展任何工作（ ）12a、软件测试只能发现错误，但不能保证测试后的软件没有错误（ ）12b、测试计划中指定的所有测试用例运行均通过，说明软件没有错误（ ）12c、软件项目进入需求分析阶段，测试人员就应该开始介入其中（ ）13、在设计测试用例时，应包括合理的输入和不合理的输入（ ）14、在进行软件测试时，只要故障代码在执行某条测试用例时被覆盖，则该测试用例的运行结果就一定是失败（ ）15a、白盒测试中，可以通过大量设计测试用例的方式，使得这些测试用例的语句覆盖率达到100%（ ）15b、白盒测试中，满足条件组合覆盖的测试用例集，一定能保证判定语句取真取假的情况出现至少各一次（ ）16、决策表中条件的数量为n，则最终决策表中规则的数量一定是2n2^n2​n​​（ ）17、自适应随机测试的错误检测效率高于随机测试（ ） 选择题1a、系统测试通常使用_______技术，主要测试被测应用的高级互操作性需求，而无需考虑被测试应用的内部结构。1b、单元测试的主要测试技术不包括（ ）A、白盒测试 B、压力测试C、静态测试 D、结构化测试2、软件生命周期中所花费用最多的阶段是______3、软件确认测试合格通过的准则是___________________4a、根据用户在软件使用过程中提出的建设性意见而进行的维护活动称为_______5、下列关于Alpha测试时的描述中正确的是__A、Alpha测试是集成测试的一种 B、Alpha测试不需要用户代表参加C、Alpha测试不需要测试人员参加 D、Alpha测试需要用户代表参加6a、关于软件测试目的的描述，以下哪些是正确的（ ）A、评价软件的质量 B、更正软件的错误C、找出软件中的所有错误 D、证明软件是正确的6b、关于软件测试目的的描述，以下哪些是错误的（ ）A、评价软件的质量 B、更正软件的错误C、找出软件中的所有错误 D、证明软件是正确的7a、下列方法中，不属于黑盒测试的是（ ）A、基本路径测试法 B、等价类测试法C、边界值分析法 D、基于场景的测试方法7b、以下不属于白盒测试的技术的是（ ）A、逻辑覆盖 B、基本路径测试C、循环覆盖测试 D、等价类划分8a、使用白盒测试方法时，确定测试数据应根据（ ）和指定的覆盖标准。A、使用说明书 B、程序的代码及结构C、需求说明书 D、程序的功能8b、使用黑盒测试方法时，确定测试数据应根据（ ）和指定的覆盖标准。A、程序的内部逻辑 B、程序的复杂结构C、程序的源代码 D、程序的功能9、测试结束的标准可能包括（ ）A、运行完指定的所有测试用例 B、覆盖率达到给定的标准C、检测到所有的错误 D、时间及其他资源耗尽10a、如果一个判定中的谓词为（A&gt;1）or（B&lt;=3），则为了达到100%的条件覆盖率，至少需要设计__个测试用例10b、如果一个判定中的谓词为（A&gt;1）or（B&lt;=3），则为了达到100%的判定条件覆盖率，至少需要设计__个测试用例10c、如果一个判定中的谓词为（A&gt;1）or（B&lt;=3），则为了达到100%的条件组合覆盖率，至少需要设计__个测试用例 简答题一、在列出等价类表后确定测试用例的具体步骤（1）首先为等价类表中的每一个等价类分别规定一个唯一的编号（2）设计一个新的测试用例，使它能够尽量覆盖尚未覆盖的有效等价类，重复这个步骤，直到所有的有效等价类均被测试用例所覆盖（3）设计一个新的测试用例，使它仅覆盖一个尚未覆盖的无效等价类，重复这一步骤，直到所有的无效等价类均被测试用例所覆盖二、为什么使用自适应随机测试自适应随机测试(Adaptive Random Testing,ART)是一种增强的随机测试,比随机测试更有效。自适应随机测试（Adaptive Random Testing）是一种更加平滑的测试用例生成技术。在给定的测试用例集中，随机选取第一个测试用例，并从集合中删除。三、自适应随机测试（Adaptive Random Testing）相对于随机测试（Random Testing）具有什么优势？自适应随机测试的检查错误的效率高于随机测试。自适应随机测试吸取随机测试的优点，并在选取测试用例时按照一定的规则，保证测试用例均匀分布在整个解空间中，提升其检测出错误的能力。四、为什么使用边界值分析法？无数的测试实践表明，大量的故障往往发生在输入定义域或输出值域的边界上，而不是在其内部，因此，针对各种边界情况设计测试用例，通常会取得很好的测试效果。五、怎样用边界值分析法设计测试用例？（1）首先确定边界情况，通常输入或输出等价类的边界就是应该着重测试的边界情况（2）选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值六、白盒测试中什么是判定／条件覆盖？它与判定覆盖和条件覆盖的关系？设计足够多的测试用例，使得程序中每个判定包含的每个条件的所有情况（真／假）至少出现一次，并且每个判定本身的判定结果（真／假）也至少出现一次——满足判定／条件覆盖的测试用例一定同时满足判定覆盖和条件覆盖七、采用因果图法设计测试用例的步骤（1）根据程序规格说明书描述，分析并确定因（输入条件）和果（输出结果或程序状态的改变），画出因果图（2）将得到的因果图转换为判定表（3）为判定表中每一列所表示的情况设计一个测试用例八、使用因果图法的优点（1）考虑到了输入情况的各种组合以及各个输入情况之间的相互制约关系（2）能够帮助测试人员按照一定的步骤，高效率的开发测试用例（3）因果图法是将自然语言规格说明转化成形式语言规格说明的一种严格的方法，可以指出规格说明存在的不完整性和二义性九、构造决策表的五个步骤（1）确定规则的个数（有n个条件的决策表有2n个规则（每个条件取真、假值））（2）列出所有的条件桩和动作桩（3）填入条件项（4）填入动作项，得到初始决策表（5）简化决策表，合并相似规则十、 适用于使用决策表设计测试用例的条件：规格说明以决策表形式给出，或较容易转换为决策表条件的排列顺序不会也不应影响执行的操作规则的排列顺序不会也不应影响执行的操作当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则如果某一规则的条件要执行多个操作，这些操作的执行顺序无关紧要十一、简述负载测试、压力测试、性能测试的联系与区别性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时系统各指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。十二、软件测试的自动化包含哪些内容？为什么要使用自动化测试？标识、设计、建立、执行、比较可以执行一些手工测试困难或者难以完成的测试，例如并发测试；更好的利用资源，可以利用整晚或周末空闲机器时间进行测试；通过较少的可以获得更彻底的测试，以及提高产品的质量十三、假设程序中存在一行错误的代码，根据PIE模型，测试用例运行‘失败’需要满足哪些条件，请给出一个简单的例子，测试用例覆盖错误代码，但测试用例运行结果‘通过’。（1）执行／可达性：必须包含程序中包含故障的位置（2）感染：程序的状态必须是不正确的（3）传播：受感染的状态必须传播导致一些输出的程序是不正确的例子：12345678910111213public static void CSta(int []numbers)&#123; int length = numbers.length; double mean, sum; sum = 0.0; for(int i = 1; i&lt;length; i++)//i=0 &#123; sum += numbers[i]; &#125; mean = sum / (double) length; System.out.println(\"mean: \" + mean);&#125;Test Input:[0,4,5] sum=0+4+5 sum=4+5 mean=3 mean=3十四、假设存在两个串行循环，且两者的循环无约束关系，如何进行测试？逻辑覆盖测试（循环测试）（1）如果串行循环的循环体是彼此之间独立的话，可以使用简单循环的测试方法循环变量的初值是否正确循环变量的最大值是否正确何时退出循环，循环变量的增量是否正确（2）两个循环串接起来，则考虑使用嵌套循环：当外循环变量为最小值，内层循环也为最小值时，运算结果当外循环变量为最小值，内层循环也为最大值时，运算结果当外循环变量为最大值，内层循环也为最小值时，运算结果当外循环变量为最大值，内层循环也为最大值时，运算结果循环变量的增量是否正确何时退出内循环何时退出外循环十五、为什么需要进行组合测试？输入输出测试、配置测试、兼容性测试等因素间的存在复杂关系，不容易简单测试，而组合测试能够在保证错误检出率的前提下采用较少的测试用例测试系统。十六、用等价类划分法设计下面的测试用例输入三个整数a、b、c，分别作为三角形的三条边，现通过程序判断由三条边构成的三角形的类型为等边三角形，等腰三角形，一般三角形（特殊的还有直角三角形），以及构不成三角形现在要求输入三个整数a，b，c，必须满足以下条件条件1： 1≤a≤100 条件4： a&lt;b+c条件2： 1≤b≤100 条件5： b&lt;a+c条件3： 1≤c≤100 条件6： c&lt;a+b如果输入值a、b、c不满足条件1、条件2和条件3，程序会给出“非法输入”的信息，如果输入值a、b、c满足条件1、条件2和条件3，则输入下列四种情况之一：（1）如果不满足条件4、条件5和条件6中的一个，则程序输出为“非三角形”。（2）如果三条边相等，则程序输出为”等边三角形“。（3）如果恰好有两条边相等，则程序输出为”等腰三角形“。（4）如果三条边都不相等，则程序输出为“一般三角形”。要求：（1）分析程序的规格说明，列出等价类表（有效等价类、无效等价类）；（2）设计若干条测试用用例以覆盖所有等价类。十七、c语言中的字符串拷贝函数声明如下：extern char *strcpy(char *dest, const char *src)头文件： #include &lt;string.h&gt;功能： 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间说明： 指针src和dest所指内存不重叠，dest有足够的空间，返回指向dest的指针请：（1）尝试给出函数的实现；（2）针对该函数的功能编写测试用例；（3）将这些测试用例用gTest（或CppUnit、或JUnit）测试代码的形式给出。1char* strcpy(char* Dest, const char* Src) &#123; assert((Dest != NULL)&amp;&amp;(Src != NULL)); if(Dest == Src)return Dest; char* tempStr = Dest; while((*(Dest++) = *(Src++)) != '/0') NULL; return tempStr; &#125;void main()&#123; clrscr();Char* strDest,*strSrc,*str;strDest=\"ABCD\";strSrc=\"EFG\";str = strcpy(strDest, strSrc);Printf(\"%s\",str);&#125;输出：EFG未完待续、、、","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"http://jimmy9876.top/tags/软件测试/"}]},{"title":"Emmet:WEB前端代码快速编写神器","slug":"Emmet-WEB前端代码快速编写神器","date":"2017-06-07T05:30:09.000Z","updated":"2017-10-16T07:16:33.209Z","comments":true,"path":"2017/06/07/Emmet-WEB前端代码快速编写神器/","link":"","permalink":"http://jimmy9876.top/2017/06/07/Emmet-WEB前端代码快速编写神器/","excerpt":"Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，当然Sublime Text也支持改插件，默认在Sublime Text3种自带了这个插件。","text":"Emmet的前身是大名鼎鼎的Zen coding，如果你从事Web前端开发的话，对该插件一定不会陌生。它使用仿CSS选择器的语法来生成代码，大大提高了HTML/CSS代码编写的速度，当然Sublime Text也支持改插件，默认在Sublime Text3种自带了这个插件。下载Sublime Text3：http://download.csdn.net/detail/u011127019/9596257 一、快速格式化Html代码，输入内容然后按Tab键（注意在输入内容的结尾处） 1.初始化，比如输入“!”或“html:5”，然后按Tab键输入标签，然后Tab键div1&lt;div&gt;&lt;/div&gt; 2.轻松添加类、id、文本和属性比如输入：div#person.top自动生成：1&lt;div id=\"person\" class=\"top\"&gt;&lt;/div&gt;比如输入：h1{标题}自动生成：&lt;h1&gt;标题&lt;/h1&gt;比如输入：a[href=#]&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; 3.嵌套现在你只需要1行代码就可以实现标签的嵌套。&gt;：子元素符号，表示嵌套的元素+：同级标签符号^：可以使该符号前的标签提升一行效果如下图所示： 4.分组你可以通过嵌套和括号来快速生成一些代码块，比如输入(.foo&gt;h1)+(.bar&gt;h2)，会自动生成如下代码：1234567891011&lt;div class=\"foo\"&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"bar\"&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/div&gt; 5.隐式标签声明一个带类的标签，只需输入div.item，就会生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。在过去版本中，可以省略掉div，即输入.item即可生成&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;。现在如果只输入.item，则Emmet会根据父标签进行判定。比如在&lt;ul&gt;中输入.item，就会生成&lt;li class=&quot;item&quot;&gt;&lt;/li&gt;。下面是所有的隐式标签名称：li：用于ul和ol中tr：用于table、tbody、thead和tfoot中td：用于tr中option：用于select和optgroup中 6.定义多个元素要定义多个元素，可以使用符号。比如，ul&gt;li3可以生成如下代码：123456789&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 7.定义多个带属性的元素如果输入 ul&gt;li.item$*3，将会生成如下代码：123456789&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;/ul&gt;更多请参考：http://www.iteye.com/news/27580文档：http://docs.emmet.io/（其中包含了一个Demo，你可以试验文中所提到的这些缩写）Via smashingmagazine更多技术干货—Jimmy的技术乐园","categories":[],"tags":[{"name":"Sublime插件","slug":"Sublime插件","permalink":"http://jimmy9876.top/tags/Sublime插件/"}]},{"title":"同花顺笔试题精选","slug":"同花顺笔试题精选","date":"2017-06-06T13:23:56.000Z","updated":"2017-10-16T07:16:33.212Z","comments":true,"path":"2017/06/06/同花顺笔试题精选/","link":"","permalink":"http://jimmy9876.top/2017/06/06/同花顺笔试题精选/","excerpt":"今天做了同花顺在线笔试，感觉还行。。。分享一下笔试题==","text":"今天做了同花顺在线笔试，感觉还行。。。分享一下笔试题== 1 2 3 4 5 6 7这张截图的时候手抖😂 8 9 10基本就是这些，答案一般来说google一下就有,我在这里就不放出来了，大家自行搜索了解==","categories":[],"tags":[{"name":"笔试","slug":"笔试","permalink":"http://jimmy9876.top/tags/笔试/"}]},{"title":"C++中的struct和class的区别","slug":"C-中的struct和class的区别","date":"2017-06-06T10:58:57.000Z","updated":"2017-10-16T07:16:33.209Z","comments":true,"path":"2017/06/06/C-中的struct和class的区别/","link":"","permalink":"http://jimmy9876.top/2017/06/06/C-中的struct和class的区别/","excerpt":"C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。struct能包含成员函数吗？ 能！struct能继承吗？ 能！！struct能实现多态吗？ 能！！！","text":"C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。struct能包含成员函数吗？ 能！struct能继承吗？ 能！！struct能实现多态吗？ 能！！！既然这些它都能实现，那它和class还能有什么区别？最本质的一个区别就是默认的访问控制，体现在两个方面： 1）默认的继承访问权限。struct是public的，class是private的。你可以写如下的代码：12345678struct A&#123;char a;&#125;；struct B : A&#123;char b;&#125;；这个时候B是public继承A的。如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。所以我们在平时写类继承的时候，通常会这样写：struct B : public A就是为了指明是public继承，而不是用默认的private继承。当然，到底默认是public继承还是private继承，取决于子类而不是基类。我的意思是，struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。如下：123struct A&#123;&#125;；class B : A&#123;&#125;; //private继承struct C : B&#123;&#125;； //public继承 2）struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。注意我上面的用词，我依旧强调struct是一种数据结构的实现体，虽然它是可以像class一样的用。我依旧将struct里的变量叫数据，class内的变量叫成员，虽然它们并无区别。其实，到底是用struct还是class，完全看个人的喜好，你可以将你程序里所有的class全部替换成struct，它依旧可以很正常的运行。但我给出的最好建议，还是：当你觉得你要做的更像是一种数据结构的话，那么用struct，如果你要做的更像是一种对象的话，那么用class。当然，我在这里还要强调一点的就是，对于访问控制，应该在程序里明确的指出，而不是依靠默认，这是一个良好的习惯，也让你的代码更具可读性。说到这里，很多了解的人或许都认为这个话题可以结束了，因为他们知道struct和class的“唯一”区别就是访问控制。很多文献上也确实只提到这一个区别。但我上面却没有用“唯一”，而是说的“最本质”，那是因为，它们确实还有另一个区别，虽然那个区别我们平时可能很少涉及。那就是：“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。这一点在Stanley B.Lippman写的Inside the C++ Object Model有过说明。问题讨论到这里，基本上应该可以结束了。但有人曾说过，他还发现过其他的“区别”，那么，让我们来看看，这到底是不是又一个区别。还是上面所说的，C++中的struct是对C中的struct的扩充，既然是扩充，那么它就要兼容过去C中struct应有的所有特性。例如你可以这样写：12345678910111213struct A //定义一个struct&#123;char c1;int n2;double db3;&#125;;A a=&#123;'p',7,3.1415926&#125;; //定义时直接赋值也就是说struct可以在定义的时候用{}赋初值。那么问题来了，class行不行呢？将上面的struct改成class，试试看。报错！噢~于是那人跳出来说，他又找到了一个区别。我们仔细看看，这真的又是一个区别吗？你试着向上面的struct中加入一个构造函数（或虚函数），你会发现什么？对，struct也不能用{}赋初值了。的确，以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面如果写成A a={‘p’,7};则c1,n2被初始化，而db3没有。这样简单的copy操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或是一个虚函数会使struct更体现出一种对象的特性，而使此{}操作不再有效。事实上，是因为加入这样的函数，使得类的内部结构发生了变化。而加入一个普通的成员函数呢？你会发现{}依旧可用。其实你可以将普通的函数理解成对数据结构的一种算法，这并不打破它数据结构的特性。那么，看到这里，我们发现即使是struct想用{}来赋初值，它也必须满足很多的约束条件，这些条件实际上就是让struct更体现出一种数据机构而不是类的特性。那为什么我们在上面仅仅将struct改成class，{}就不能用了呢？其实问题恰巧是我们之前所讲的——访问控制！你看看，我们忘记了什么？对，将struct改成class的时候，访问控制由public变为private了，那当然就不能用{}来赋初值了。加上一个public，你会发现，class也是能用{}的，和struct毫无区别！！！做个总结，从上面的区别，我们可以看出，struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。来自：http://hi.baidu.com/pengxiangbobin19890125/blog/item/b05586eee77300212df53411.html","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://jimmy9876.top/tags/C/"}]},{"title":"MPV播放器使用手册","slug":"MPV播放器使用手册","date":"2017-06-06T08:54:21.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/06/06/MPV播放器使用手册/","link":"","permalink":"http://jimmy9876.top/2017/06/06/MPV播放器使用手册/","excerpt":"最近换了视频播放器，因为搜索到的内容大都对 mpv 一片好评，所以开始试用 mpv。他是个单文件播放器，是mplayer和mplayer2的活跃分支（可能也是最活跃？）","text":"最近换了视频播放器，因为搜索到的内容大都对 mpv 一片好评，所以开始试用 mpv。他是个单文件播放器，是mplayer和mplayer2的活跃分支（可能也是最活跃？） 默认快捷键跟大多数播放器类似的常用快捷键SPACE 暂停/播放切换UP 快进 60 秒DOWN 回退 60 秒LEFT 回退 5 秒RIGHT 快进 5 秒其他常用快捷键j 循环选择字幕J 反向循环选择字幕# 循环切换音轨f 切换全屏状态T 切换视频窗口是否总在最前s 视频截图，包含字幕S 视频截图，不带字幕Alt+s 自动逐帧视频截图，再按一次停止截图. 进到下一帧, 退到前一帧9 音量减 20 音量加 2[ 0.9091 倍慢速播放] 1.1 倍快速播放{ 0.5 倍慢速播放} 2 倍快速播放Backspace 重置为正常播放速度 官方文档mpv keybindingsmpv options","categories":[],"tags":[{"name":"mpv","slug":"mpv","permalink":"http://jimmy9876.top/tags/mpv/"}]},{"title":"进程与线程的一个简单解释","slug":"进程与线程的一个简单解释","date":"2017-06-05T13:36:31.000Z","updated":"2017-10-16T07:16:33.214Z","comments":true,"path":"2017/06/05/进程与线程的一个简单解释/","link":"","permalink":"http://jimmy9876.top/2017/06/05/进程与线程的一个简单解释/","excerpt":"","text":"进程与线程的一个简单解释进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。今天看到一篇文章，发现有一个很好的类比，可以把它们解释地清晰易懂。计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&quot;互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&quot;信号量&quot;（Semaphore），用来保证多个线程不会互相冲突。不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。操作系统的设计，因此可以归结为三点：（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://jimmy9876.top/tags/操作系统/"}]},{"title":"js闭包","slug":"js闭包","date":"2017-06-04T13:07:05.000Z","updated":"2017-10-16T07:16:33.211Z","comments":true,"path":"2017/06/04/js闭包/","link":"","permalink":"http://jimmy9876.top/2017/06/04/js闭包/","excerpt":"JavaScript 闭包JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。","text":"JavaScript 闭包JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。 全局变量函数可以访问\b由函数内部定义的变量，如： 实例1234function myFunction() &#123; var a = 4; return a * a;&#125;函数也可以访问函数外部定义的变量，如： 实例1234var a = 4;function myFunction() &#123;​ return a * a;&#125;后面一个实例中， a 是一个 全局 变量。在web页面中全局变量属于 window 对象。全局变量可应用于页面上的所有脚本。在第一个实例中， a 是一个 局部 变量。局部变量只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义。 变量生命周期全局变量的作用域是全局性的，即在整个JavaScript程序中，全局变量处处都在。而在函数内部声明的变量，只在函数内部起作用。这些变量是局部变量，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。 计数器困境设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。你可以使用全局变量，函数设置计数器递增： 实例12345678var counter = 0;function add() &#123; return counter += 1;&#125;add();add();add();// 计数器现在为 3计数器数值在执行 add() 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器，即便没有调用 add() 函数。如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值： 实例12345678function add() &#123;​ var counter = 0;​ counter += 1;&#125;add();add();add();// 本意是想输出 3, 但事与愿违，输出的都是 1 !以上代码将无法正确输出，每次我调用 add() 函数，计数器都会设置为 1。JavaScript 内嵌函数可以解决该问题。 JavaScript 内嵌函数所有函数都能访问全局变量。实际上，在 JavaScript 中，所有函数都能访问它们上一层的作用域。JavaScript 支持嵌套函数。嵌套函数可以访问上一层的函数变量。该实例中，内嵌函数 plus() 可以访问父函数的 counter 变量： 实例123456function add() &#123;​ var counter = 0;​ function plus() &#123;counter += 1;&#125;​ plus(); ​ return counter; &#125;如果我们能在外部访问 plus() 函数，这样就能解决计数器的困境。我们同样需要确保 counter = 0 只执行一次。我们需要闭包。 JavaScript 闭包还记得函数自我调用吗？该函数会做什么？ 实例12345678var add = (function () &#123;​ var counter = 0;​ return function () &#123;return counter += 1;&#125;&#125;)();add();add();add();// 计数器为 3 实例解析变量 add 指定了函数自我调用的返回字值。自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。这个叫作 JavaScript **闭包。**它使得函数拥有私有变量变成可能。计数器受匿名函数的作用域保护，只能通过 add 方法修改。闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jimmy9876.top/tags/javascript/"}]},{"title":"HTTP状态码","slug":"HTTP状态码","date":"2017-06-04T12:39:47.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/06/04/HTTP状态码/","link":"","permalink":"http://jimmy9876.top/2017/06/04/HTTP状态码/","excerpt":"当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。","text":"当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。HTTP状态码的英文为HTTP Status Code。下面是常见的HTTP状态码：200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误 HTTP状态码分类HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：分类分类描述1**信息，服务器收到请求，需要请求者继续执行操作2**成功，操作被成功接收并处理3**重定向，需要进一步的操作以完成请求4**客户端错误，请求包含语法错误或无法完成请求5**服务器错误，服务器在处理请求的过程中发生了错误HTTP状态码列表:状态码状态码英文名称中文描述100Continue继续。客户端应继续其请求101Switching Protocols切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200OK请求成功。一般用于GET与POST请求201Created已创建。成功请求并创建了新的资源202Accepted已接受。已经接受请求，但未处理完成203Non-Authoritative Information非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204No Content无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205Reset Content重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206Partial Content部分内容。服务器成功处理了部分GET请求300Multiple Choices多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302Found临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303See Other查看其它地址。与301类似。使用GET和POST请求查看304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305Use Proxy使用代理。所请求的资源必须通过代理访问306Unused已经被废弃的HTTP状态码307Temporary Redirect临时重定向。与302类似。使用GET请求重定向400Bad Request客户端请求的语法错误，服务器无法理解401Unauthorized请求要求用户的身份认证402Payment Required保留，将来使用403Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求404Not Found服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面405Method Not Allowed客户端请求中的方法被禁止406Not Acceptable服务器无法根据客户端请求的内容特性完成请求407Proxy Authentication Required请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408Request Time-out服务器等待客户端发送的请求时间过长，超时409Conflict服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410Gone客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411Length Required服务器无法处理客户端发送的不带Content-Length的请求信息412Precondition Failed客户端请求信息的先决条件错误413Request Entity Too Large由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414Request-URI Too Large请求的URI过长（URI通常为网址），服务器无法处理415Unsupported Media Type服务器无法处理请求附带的媒体格式416Requested range not satisfiable客户端请求的范围无效417Expectation Failed服务器无法满足Expect的请求头信息500Internal Server Error服务器内部错误，无法完成请求501Not Implemented服务器不支持请求的功能，无法完成请求502Bad Gateway充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503Service Unavailable由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504Gateway Time-out充当网关或代理的服务器，未及时从远端服务器获取请求505HTTP Version not supported服务器不支持请求的HTTP协议的版本，无法完成处理","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://jimmy9876.top/tags/HTTP/"}]},{"title":"CSS中margin和padding的区别","slug":"CSS中margin和padding的区别","date":"2017-06-03T08:56:57.000Z","updated":"2017-10-16T07:16:33.209Z","comments":true,"path":"2017/06/03/CSS中margin和padding的区别/","link":"","permalink":"http://jimmy9876.top/2017/06/03/CSS中margin和padding的区别/","excerpt":"padding margin都是边距的含义，关键问题得明白是什么相对什么的边距．padding是控件的内容相对控件的边缘的边距．margin是控件边缘相对父空间的边距．","text":"padding margin都是边距的含义，关键问题得明白是什么相对什么的边距．padding是控件的内容相对控件的边缘的边距．margin是控件边缘相对父空间的边距．在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。在CSS中padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内距离。下面是 padding和margin常用的用法一、padding1、语法结构（1）padding-left:10px; 左内边距（2）padding-right:10px; 右内边距（3）padding-top:10px; 上内边距（4）padding-bottom:10px; 下内边距（5）padding：10px; 四边统一内边距（6）padding:10px 20px; 上下、左右内边距（7）padding:10px 20px 30px; 上、左右、下内边距（8）padding:10px 20px 30px 40px; 上、右、下、左内边距2、可能取的值（1）length 规定具体单位记的内边距长度（2）% 基于父元素的宽度的内边距的长度（3）auto 浏览器计算内边距（4）inherit 规定应该从父元素继承内边距3、浏览器兼容问题（1）所有浏览器都支持padding属性（2）任何版本IE都不支持属性值“inherit”二、margin1、语法结构（1）margin-left:10px; 左外边距（2）margin-right:10px; 右外边距（3）margin-top:10px; 上外边距（4）margin-bottom:10px; 下外边距（5）margin:10px; 四边统一外边距（6）margin:10px 20px; 上下、左右外边距（7）margin:10px 20px 30px; 上、左右、下外边距（8）margin:10px 20px 30px 40px; 上、右、下、左外边距2、可能取的值（1）length 规定具体单位记的外边距长度（2）% 基于父元素的宽度的外边距的长度（3）auto 浏览器计算外边距（4）inherit 规定应该从父元素继承外边距3、浏览器兼容问题（1）所有浏览器都支持margin属性（2）任何版本IE都不支持属性值“inherit”三、margin和padding的区别用图表示为","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://jimmy9876.top/tags/css/"}]},{"title":"php面试题-2-附答案","slug":"php面试题-2-附答案","date":"2017-06-01T11:07:40.000Z","updated":"2017-10-16T07:16:33.212Z","comments":true,"path":"2017/06/01/php面试题-2-附答案/","link":"","permalink":"http://jimmy9876.top/2017/06/01/php面试题-2-附答案/","excerpt":"","text":"1、双引号和单引号的区别双引号解释变量，单引号不解释变量双引号里插入单引号，其中单引号里如果有变量的话，变量解释双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误双引号解释转义字符，单引号不解释转义字符，但是解释’\\和\\能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断） 2、常用的超全局变量(8个)$_GET -----&gt;get传送方式$POST -----&gt;post传送方式$REQUEST -----&gt;可以接收到get和post两种方式的值$GLOBALS -----&gt;所有的变量都放在里面$FILE -----&gt;上传文件使用$SERVER -----&gt;系统环境变量$SESSION -----&gt;会话控制的时候会用到$COOKIE -----&gt;会话控制的时候会用到 3、HTTP中POST、GET、PUT、DELETE方式的区别HTTP定义了与服务器交互的不同的方法，最基本的是POST、GET、PUT、DELETE，与其比不可少的URL的全称是资源描述符，我们可以这样理解：url描述了一个网络上资源，而post、get、put、delete就是对这个资源进行增、删、改、查的操作！ 3.1表单中get和post提交方式的区别get是把参数数据队列加到提交表单的action属性所指的url中，值和表单内各个字段一一对应，从url中可以看到；post是通过HTTP POST机制，将表单内各个字段与其内容防止在HTML的head中一起传送到action属性所指的url地址，用户看不到这个过程对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据get传送的数据量较小，post传送的数据量较大，一般被默认不受限制，但在理论上，IIS4中最大量为80kb，IIS5中为1000k，get安全性非常低，post安全性较高 3.2GET请求会向数据库发索取数据的请求，从而来获取信息，该请求就像数据库的select操作一样，只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容，即该请求不会产生副作用。无论进行多少次操作，结果都是一样的。与GET不同的是，PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样，用来修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的insert操作一样，会创建新的内容。几乎目前所有的提交操作都是用POST请求的。DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 4、PHP介绍Hypertext Preprocessor----超文本预处理器Personal Home Page 原始名称目标用途: 允许web开发人员快速编写动态生成的web页面，与其他页面相比，PHP是将程序嵌入到HTML文档中去执行，效率比完全生成HTML编辑的CGI高很多HTML: Hypertext Markup Language创始人: 拉姆斯勒·勒多夫Rasmus Lerdorf，1968年生，加拿大滑铁卢大学勒多夫最开始是为了维护个人网页，用prel语言写了维护程序，之后又用c进行了重写，最终衍生出php/fi时间轴:1995.06.08将PHP/FI公开释出1995 php2.0，加入了对MySQL的支持1997 php3.02000 php4.02008 php5.0由于php6.0没有完全解决Unicode编码，所以基本没有生产线上的应用，基本只是一款概念产品，很多功能已经在php5.3.3和php5.3.4上实现常见的IDE(Intergrated Development Environment): 集成开发环境Coda（mac）PHPStromAdobe DreamweaverNetBeans常见文本编辑器，具备代码高亮：NodePad++SublimeText PHP优势PHP特性:php独特混合了C,Java,Prel以及PHP自创的语法可以比CGI或者Prel更快速去执行动态网页，与其他变成语言相比，PHP是讲程序嵌入到HTML文档中去执行，执行效率比完全生成HTML编辑的CGI要高很多，所有的CGI都能实现支持几乎所有流行的数据库以及操作系统PHP可以使用C,C++进行程序的扩展PHP优势:开放源代码免费性快捷性跨平台强效率高图形处理面向对象专业专注PHP技术应用:静态页面生成数据库缓存过程缓存div+css w3c标准大负荷分布式flex支持MVCSmarty模块引擎 PHP认证级别初级 IFE:Index Front Engineer 前端工程师中级 IPE:Index PHP Engineer PHP工程师高级 IAE:Index Architecture Engineer 架构工程师 6、echo、print_r、print、var_dump之间的区别12345* echo、print是php语句，var_dump和print_r是函数* echo 输出一个或多个字符串，中间以逗号隔开，没有返回值是语言结构而不是真正的函数，因此不能作为表达式的一部分使用* print也是php的一个关键字，有返回值 只能打印出简单类型变量的值(如int，string)，如果字符串显示成功则返回true，否则返回false* print_r 可以打印出复杂类型变量的值(如数组、对象）以列表的形式显示，并以array、object开头，但print_r输出布尔值和NULL的结果没有意义，因为都是打印&quot;\\n&quot;，因此print_r()函数更适合调试* var_dump() 判断一个变量的类型和长度，并输出变量的数值 7、HTTP状态码点击这儿查看HTTP状态码详解常见的HTTP状态码：200 - 请求成功301 - 资源(网页等)被永久转义到其他URL404 - 请求的资源(网页等)不存在505 - 内部服务器错误HTTP状态码分类:1** - 信息，服务器收到的请求，需要请求者继续执行操作2** - 成功，操作被成功接收并处理3** - 重定向，需要进一步的操作以完成请求4** - 客户端错误，请求包含语法错误或者无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错误 8、什么是魔术引号魔术引号是一个将自动将进入PHP脚本的数据进行转义的过程，最好在编码时不要转义而在运行时根据需要而转义 9、如何获取客户端的ip(要求取得一个int)和服务器ip的代码客户端：$_SERVER[&quot;REMOTE_ADDR&quot;];或者getenv('REMOTE_ADDR')ip2long进行转换服务器端：gethostbyname('www.baidu.com') 10、使用那些工具进行版本控制cvs、svn、vss、git 11、优化数据库的方法 MySQL数据库优化的八大方式（经典必看）点击获取选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、'性别’最好适用ENUM使用连接(JOIN)来代替子查询适用联合(UNION)来代替手动创建的临时表事务处理锁定表、优化事务处理适用外键，优化锁定表建立索引优化查询语句 12、是否使用过模板引擎？使用的模板引擎的名字是？Smarty:Smarty算是一种很老的PHP模板引擎了，它曾是我使用这门语言模板的最初选择。虽然它的更新已经不算频繁了，并且缺少新一代模板引擎所具有的部分特性，但是它仍然值得一看。 13、对于大流量网站，采用什么方法来解决访问量的问题确认服务器硬件是否能够支持当前的流量数据库读写分离，优化数据表程序功能规则，禁止外部的盗链控制大文件的下载使用不同主机分流主要流量 14、语句include和require的区别是什么？为避免多次包含同一文件，可以用(?)语句代替他们require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行include有返回值，而require没有(可能因为如此require的速度比include快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去注意:包含文件不存在或者语法错误的时候require是致命的，而include不是require_once表示了只包含一次，避免了重复包含 15、谈谈mvc的认识由模型、视图、控制器完成的应用程序，由模型发出要实现的功能到控制器，控制器接收组织功能传递给视图 16、 说明php中传值与传引用的区别，并说明传值什么时候传引用？变量默认总是传值赋值，那也就是说，当将一个表达式的值赋予一个变量时，整个表达式的值被赋值到目标变量，这意味着：当一个变量的赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量php也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的__引用__*(换言之，成为了其别名或者指向)*了原始变量。改动的新的变量将影响到原始变量，反之亦然。使用引用赋值，简单地将一个&amp;符号加到将要赋值的变量前(源变量)对象默认是传引用对于较大是的数据，传引用比较好，这样可以节省内存的开销. 17、isset、empty、is_null的区别isset 判断变量是否定义或者是否为空1234变量存在返回ture，否则返回false变量定义不赋值返回falseunset一个变量，返回false变量赋值为null，返回falseempty：判断变量的值是否为空，能转换为false的都是空，为空返回true，反之返回false。12&quot;&quot;,0,&quot;0&quot;,NULL，FALSE都认为为空，返回true没有任何属性的对象都认为是空is_null：检测传入的值(值、变量、表达式)是否为null123定义了，但是赋值为Null定义了，但是没有赋值unset一个变量 18、前端调试的工具Firefox的firebugChrome的开发工具EmmetJSON格式校验工具 19. 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）（新浪网技术部）索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。 20.数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。ACID 四大特性,原子性、隔离性、一致性、持久性。 21.了解XSS攻击吗？如何防止？XSS是跨站脚本攻击，首先是利用跨站脚本漏洞以一个特权模式去执行攻击者构造的脚本，然后利用不安全的Activex控件执行恶意的行为。使用htmlspecialchars()函数对提交的内容进行过滤，使字符串里面的特殊符号实体化。 22.SQL注入漏洞产生的原因？如何防止？SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。 防止SQL注入的方式：开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置执行sql语句时使用addslashes进行sql语句转换Sql语句书写尽量不要省略双引号和单引号。过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。Php配置文件中设置register_globals为off,关闭全局变量注册控制错误信息，不要在浏览器上输出错误信息，将错误信息写到日志文件中。 23.PHP网站的主要攻击方式有哪些？命令注入(Command Injection)eval 注入(Eval Injection)客户端脚本攻击(Script Insertion)跨网站脚本攻击(Cross Site Scripting, XSS)SQL 注入攻击(SQL injection)跨网站请求伪造攻击(Cross Site RequestForgeries, CSRF)Session 会话劫持(Session Hijacking)Session 固定攻击(Session Fixation)HTTP 响应拆分攻击(HTTP Response Splitting)文件上传漏洞(File Upload Attack)目录穿越漏洞(Directory Traversal)远程文件包含攻击(Remote Inclusion)动态函数注入攻击(Dynamic VariableEvaluation)URL 攻击(URL attack)表单提交欺骗攻击(Spoofed FormSubmissions)HTTP 请求欺骗攻击(Spoofed HTTP Requests) 24、框架中什么是单一入口和多入口 ， 单一入口的优缺点？多口就是通过访问不同的文件来完成用户请求。单一入口只 web 程序所有的请求都指向一个脚本文件的。单一入口更容易控制权限，方便对 http 请求可以进行安全性检查。缺点：URL 看起来不那么美观，特别是对搜索引擎来说不友好。 25、 对于关系型数据库而言，索引是相当重要的概念，请回答有关索引的几个问题： a)、索引的目的是什么？快速访问数据表中的特定信息，提高检索速度创建唯一性索引，保证数据库表中每一行数据的唯一性。加速表和表之间的连接使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间 b)、索引对数据库系统的负面影响是什么？负面影响：创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。 c)、为数据表建立索引的原则有哪些？在最频繁使用的、用以缩小查询范围的字段上建立索引。在频繁使用的、需要排序的字段上建立索引 d)、 什么情况下不宜建立索引？对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。 26、 简述在MySQL数据库中MyISAM和InnoDB的区别区别于其他数据库的最重要的特点就是其插件式的表存储引擎。切记：存储引擎是基于表的，而不是数据库。InnoDB与MyISAM的区别：InnoDB存储引擎: 主要面向OLTP(Online Transaction Processing，在线事务处理)方面的应用，是第一个完整支持ACID事务的存储引擎(BDB第一个支持事务的存储引擎，已经停止开发)。特点：行锁设计、支持外键；支持类似于Oracle风格的一致性非锁定读(即：默认情况下读取操作不会产生锁)；InnoDB将数据放在一个逻辑的表空间中，由InnoDB自身进行管理。从MySQL4.1版本开始，可以将每个InnoDB存储引擎的表单独存放到一个独立的ibd文件中；InnoDB通过使用MVCC(多版本并发控制：读不会阻塞写，写也不会阻塞读)来获得高并发性，并且实现了SQL标准的4种隔离级别(默认为REPEATABLE级别)；InnoDB还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能；InnoDB采用了聚集(clustered)的方式来存储表中的数据，每张标的存储都按主键的顺序存放(如果没有显式的在建表时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键)；InnoDB表会有三个隐藏字段：除了上面提到了6字节的DB_ROW_ID外，还有6字节的DB_TX_ID(事务ID)和7字节的DB_ROLL_PTR(指向对应回滚段的地址)。这个可以通过innodb monitor看到；MyISAM存储引擎: 是MySQL官方提供的存储引擎，主要面向OLAP(Online Analytical Processing,在线分析处理)方面的应用。特点：不支持事务，支持表所和全文索引。操作速度快；MyISAM存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。MySQL数据库只缓存其索引文件，数据文件的缓存交给操作系统本身来完成；MySQL5.0版本开始，MyISAM默认支持256T的单表数据； 27、 解释MySQL外连接、内连接与自连接的区别先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。 28、 写出三种以上MySQL数据库存储引擎的名称（提示：不区分大小写）MyISAM、InnoDB、BDB（BerkeleyDB）、Merge、Memory（Heap）、Example、Federated、Archive、CSV、Blackhole、MaxDB 等等十几个引擎 29、 什么是面向对象？主要特征是什么？几大原则是什么？面向对象是程序的一种设计模式，它利于提高程序的重用性，使程序机构更加清晰。 主要特征是：封装、继承、多态。五大基本原则： 单一职责原则；开放封闭原则；替换原则； 依赖原则； 接口分离原则。 30、什么是静态路由，其特点是什么?什么是动态路由，其特点是什么?参考答案：静态路由是由系统管理员设计与构建的路由表规定的路由。适用于网关数量有限的场 合，且网络拓朴结构不经常变化的网络。其缺点是不能动态地适用网络状况的变化，当 网络状况变化后必须由网络管理员修改路由表。动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信 息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。其 缺点是路由广播更新信息将占据大量的网络带宽。 31、使用过 Memcache 缓存吗，如果使用过，能够简单的描述一下它的工作原理吗？Memcahce 是把所有的数据保存在内存当中，采用 hash 表的方式，每条数据由 key 和 value 组成，每个 key 是独一无二的，当要访问某个值的时候先按照找到值，然后返回结果。Memcahce 采用 LRU 算法来逐渐把过期数据清除掉。 32. 列举流行的 Ajax 框架？说明 Ajax 实现原理是什么及 json 在 Ajax 中起什么作用？流行的 Ajax 框架有 jQuery，Prototype，Dojo，MooTools。Ajax 的工作原理是一个页面的指定位置可以加载另一个页面所有的输出内容，这样就实现了一个静态页面也能获取到数据库中的返回数据信息了。所以 Ajax 技术实现了一个静态网页在不刷新整个页面的情况下与服务器通信，减少了用户等待时间，同时也从而降低了网络流量，增强了客户体验的友好程度。在使用 Ajax 时，涉及到数据传输，即将数据从服务器返回到客户端，服务器端和客户端分别使用不同的脚步语言来处理数据，这就需要一种通用的数据格式，XML 和 json 就是最常用的两种，而 json 比 XML 更简单。 33、Myql中的事务回滚机制概述事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://jimmy9876.top/tags/php/"}]},{"title":"php面试题-1[附答案]","slug":"php面试题-1-附答案","date":"2017-05-30T09:27:50.000Z","updated":"2017-10-16T07:16:33.212Z","comments":true,"path":"2017/05/30/php面试题-1-附答案/","link":"","permalink":"http://jimmy9876.top/2017/05/30/php面试题-1-附答案/","excerpt":"一份不错的php面试题,附答案","text":"一份不错的php面试题,附答案一、基础题写出如下程序的输出结果1234567891011&lt;?php $str1 = null; $str2 = false; echo $str1==$str2 ? &apos;相等&apos; : &apos;不相等&apos;; $str3 = &apos;&apos;; $str4 = 0; echo $str3==$str4 ? &apos;相等&apos; : &apos;不相等&apos;; $str5 = 0; $str6 = &apos;0&apos;; echo $str5===$str6 ? &apos;相等&apos; : &apos;不相等&apos;;?&gt;写出如下程序的输出结果123456789101112131415161718&lt;?php $a1 = null; $a2 = false; $a3 = 0; $a4 = &apos;&apos;; $a5 = &apos;0&apos;; $a6 = &apos;null&apos;; $a7 = array(); $a8 = array(array()); echo empty($a1) ? &apos;true&apos; : &apos;false&apos;; echo empty($a2) ? &apos;true&apos; : &apos;false&apos;; echo empty($a3) ? &apos;true&apos; : &apos;false&apos;; echo empty($a4) ? &apos;true&apos; : &apos;false&apos;; echo empty($a5) ? &apos;true&apos; : &apos;false&apos;; echo empty($a6) ? &apos;true&apos; : &apos;false&apos;; echo empty($a7) ? &apos;true&apos; : &apos;false&apos;; echo empty($a8) ? &apos;true&apos; : &apos;false&apos;;?&gt;写出如下程序的输出结果123456&lt;?php $test = &apos;aaaaaa&apos;; $abc = &amp; $test; unset($test); echo $abc;?&gt;写出如下程序的输出结果1234567891011&lt;?php $count = 5; function get_count()&#123; static $count = 0; return $count++; &#125; echo $count; ++$count; echo get_count(); echo get_count();?&gt;写出如下程序的输出结果123456789101112&lt;?php $GLOBALS[&apos;var1&apos;] = 5; $var2 = 1; function get_value()&#123; global $var2; $var1 = 0; return $var2++; &#125; get_value(); echo $var1; echo $var2;?&gt;写出如下程序的输出结果1234567891011&lt;?php function get_arr($arr)&#123; unset($arr[0]); &#125; $arr1 = array(1, 2); $arr2 = array(1, 2); get_arr(&amp;$arr1); get_arr($arr2); echo count($arr1); echo count($arr2);?&gt;使用五种以上方式获取一个文件的扩展名要求：dir/upload.image.jpg，找出 .jpg 或者 jpg ，必须使用PHP自带的处理函数进行处理，方法不能明显重复，可以封装成函数，比如 get_ext1(filename),getext2(file_name), get_ext2(file​n​​ame),get​e​​xt2(file_name)二、算法题使用PHP描述冒泡排序和快速排序算法，对象可以是一个数组使用PHP描述顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，对象可以是一个有序数组写一个二维数组排序算法函数，能够具有通用性，可以调用php内置函数【答案】（以下答案不一定是最好的，只是一个简单的参考）一、基础题相等 相等 不相等true true true true true false true falseaaaaaa 参考: http://my.oschina.net/banbo/blog/303306 里面的结论二5 0 15 21 2使用五种以上方式获取一个文件的扩展名123456789101112131415function get_ext1($file_name)&#123; return strrchr($file_name, &apos;.&apos;);&#125;function get_ext2($file_name)&#123; return substr($file_name, strrpos($file_name, &apos;.&apos;));&#125;function get_ext3($file_name)&#123; return array_pop(explode(&apos;.&apos;, $file_name));&#125;function get_ext4($file_name)&#123; return pathinfo($file_name, PATHINFO_EXTENSION);&#125;function get_ext5($file_name)&#123; return strrev(substr(strrev($file_name), 0, strpos(strrev($file_name), &apos;.&apos;)));&#125;二、算法题使用PHP描述冒泡排序和快速排序算法，对象可以是一个数组冒泡排序（数组排序）1234567891011121314function bubble_sort($array)&#123; $count = count($array); if ($count &lt;= 0) return false; for($i=0; $i&lt;$count; $i++)&#123; for($j=$i; $j&lt;$count-1; $j++)&#123; if ($array[$i] &gt; $array[$j])&#123; $tmp = $array[$i]; $array[$i] = $array[$j]; $array[$j] = $tmp; &#125; &#125; &#125; return $array;&#125;快速排序（数组排序）123456789101112131415function quick_sort($array) &#123; if (count($array) &lt;= 1) return $array; $key = $array[0]; $left_arr = array(); $right_arr = array(); for ($i=1; $i&lt;count($array); $i++)&#123; if ($array[$i] &lt;= $key) $left_arr[] = $array[$i]; else $right_arr[] = $array[$i]; &#125; $left_arr = quick_sort($left_arr); $right_arr = quick_sort($right_arr); return array_merge($left_arr, array($key), $right_arr);&#125;使用PHP描述顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，对象可以是一个有序数组二分查找（数组里查找某个元素）12345678910111213function bin_sch($array, $low, $high, $k)&#123; if ($low &lt;= $high)&#123; $mid = intval(($low+$high)/2); if ($array[$mid] == $k)&#123; return $mid; &#125;elseif ($k &lt; $array[$mid])&#123; return bin_sch($array, $low, $mid-1, $k); &#125;else&#123; return bin_sch($array, $mid+1, $high, $k); &#125; &#125; return -1;&#125;顺序查找（数组里查找某个元素）12345678910111213function seq_sch($array, $n, $k)&#123; $array[$n] = $k; for($i=0; $i&lt;$n; $i++)&#123; if($array[$i]==$k)&#123; break; &#125; &#125; if ($i&lt;$n)&#123; return $i; &#125;else&#123; return -1; &#125;&#125;写一个二维数组排序算法函数，能够具有通用性，可以调用php内置函数二维数组排序， arr是数据，keys是排序的健值，$order是排序规则，1是升序，0是降序1234567891011121314151617181920212223function array_sort($arr, $keys, $order=0) &#123; if (!is_array($arr)) &#123; return false; &#125; $keysvalue = array(); foreach($arr as $key =&gt; $val) &#123; $keysvalue[$key] = $val[$keys]; &#125; if($order == 0)&#123; asort($keysvalue); &#125;else &#123; arsort($keysvalue); &#125; reset($keysvalue); foreach($keysvalue as $key =&gt; $vals) &#123; $keysort[$key] = $key; &#125; $new_array = array(); foreach($keysort as $key =&gt; $val) &#123; $new_array[$key] = $arr[$val]; &#125; return $new_array;&#125;原文地址","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://jimmy9876.top/tags/php/"}]},{"title":"Hexo+Next主题个性化配置-1","slug":"Hexo-Next主题个性化配置-1","date":"2017-05-30T02:53:55.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/05/30/Hexo-Next主题个性化配置-1/","link":"","permalink":"http://jimmy9876.top/2017/05/30/Hexo-Next主题个性化配置-1/","excerpt":"折腾了next这么久，就写一篇博客来记录一下，以作备忘，同时也给后来人一些借鉴","text":"折腾了next这么久，就写一篇博客来记录一下，以作备忘，同时也给后来人一些借鉴 NexT主题安装使用 本地环境自行安装 git 和 Node.js 不会的可百度，安装方法一堆。 安装HexoGit 和 Node.js 都安装好后,首先创建一个用于存放博客文件的文件夹，如 blog，然后进入 blog 文件夹，下面开始安装并使用 Hexo。右键选择 Git Bash Here，弹出 Git Bash 窗口；执行命令：12$ npm install -g hexo-cli$ hexo init安装完成后，指定文件夹的目录如下：1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes其中 _config.yml 文件用于存放网站的配置信息，你可以在此配置大部分的参数； scaffolds 是存放模板的文件夹，当新建文章时，Hexo 会根据 scaffold 来建立文件； source 是资源文件夹，用于存放用户资源， themes是主题文件夹，存放博客主题， Hexo 会根据主题来生成静态页面。在 Git Bash 终端执行命令：12$ hexo g$ hexo sHexo将 source 文件夹中的Markdown 和 HTML 文件会被解析并放到 public 文件夹中， public 文件夹用于存放静态博客文件，相当于网站根目录。至此博客雏形基本完成，在浏览器中访问 http://localhost:4000/ ，就可以访问本地博客了。 使用NexT主题在 Git Bash 终端执行以下命令：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next打开站点配置文件 _config.yml，找到 theme 字段，并将其值更改为 next 。1theme: nextNexT主题是我用过的唯一的一款Hexo主题，界面简约，功能齐全且多样，响应式设计，电脑，手机访问效果很好。在 Git Bash 终端执行命令 hexo s ，在浏览器中访问 http://localhost:4000/ ，可以看到默认的NexT-Muse主题。我喜欢双栏的故使用 NexT.Pisces 主题，修改主题配置文件 _config.yml的 Schemes 字段的值为：1scheme: Pisces Next主题宽度调节现在一般都用宽屏显示器，博客页面两侧留白太多，调整一下宽度。打开 \\themes\\next\\source\\css\\_common\\components\\post\\post-expand.styl 文件，找到1@media (max-width: 767px)改为1@media (max-width: 1080px)打开 \\themes\\next\\source\\css\\ _variables\\base.styl 文件，找到123$main-desktop = 960px$main-desktop-large = 1200px$content-desktop = 700px修改 $main-desktop 和 $content-desktop 的数值：123$main-desktop = 1080px$main-desktop-large = 1200px$content-desktop = 810pxNext.Mist 主题的文章宽度至此改完了。如果你用的是 Next.Pisces，还需要继续修改。打开 \\themes\\next\\source\\css\\_schemes\\Pisces\\_layout.styl 文件，将第 4 行的 width改为1080px ，修改后如下：1234.header &#123; position: relative; margin: 0 auto; width: 1080px;记录一下我常用的细节改动，参考了许多博友的设置，并不是我的原创。参考网站，会在文章最底部列出，以示谢意。 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。修改文件 themes\\next\\source\\css\\_common\\components\\post\\post.styl ，添加如下css样式，：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式。 文章底部的那个带#号的标签文章底部的那个带#号的标签，比如#NexT，可以把#换成图标吗，怎么设置?修改模板 layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 首页展示文章动画效果和图片放大镜效果关闭哪改？文章动画效果关闭：主题配置里 Motion: 改为 false关闭图片放大镜效果: 主题配置里 fancybox: 改为 false hexo背景动态效果和心心博客背景动态效果图和点击小红心效果的相关设置。把 js 文件 love.js 和 particle.js 放在 \\themes\\next\\source\\js\\src 文件目录下更新 \\themes\\next\\layout\\_layout.swig 文件，在末尾（在前面引用会出现找不到的bug）添加以下 js 引入代码：1234&lt;!-- 背景动画 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;想设置动画线条颜色可改为：1&lt;script type=&quot;text/javascript&quot; color=&quot;255,0,0&quot; opacity=&quot;0.3&quot; count=&quot;99&quot; src=&quot;particle.js&quot;&gt;&lt;/script&gt;就能显示红色。或者用：1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particles.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt;两个JS下载为：12http://7u2ss1.com1.z0.glb.clouddn.com/love.jshttp://7u2ss1.com1.z0.glb.clouddn.com/particle.js hexo NexT主题首页title的优化更改 index.swig 文件，文件路径是 your-hexo-site\\themes\\next\\layout ，将下面代码1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;改成1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;这时候你的首页标题会更符合网站名称 - 网站描述这习惯。进阶，做了 seo 优化，把关键词也显示在 Title 标题里，可改成1&#123;% block title %&#125; &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;**注意：**别堆砌关键字，整个标题一般不超过 80 个字符，可以通过chinaz的seo综合查询检查。 每篇文章末尾统一添加“本文结束”标记 新建 passage-end-tag.swig 文件在路径 \\themes\\next\\layout\\_macro 中添加 passage-end-tag.swig 文件，其内容为：12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢阅读------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 修改 post.swig 文件在 \\themes\\next\\layout\\_macro\\post.swig 中， post-body 之后， post-footer 之前添加如下代码（post-footer之前两个DIV）：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段在主题配置文件 _config.yml 中添加以下字段开启此功能：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true完成以上设置之后，在每篇文章之后都会添加“本文结束”标记。 增加HIGH一下功能在 themes\\next\\layout\\_macro 目录下增加 high.swig 文件，我已改为歌曲循环和多次点击不重复！地址为:1http://7u2ss1.com1.z0.glb.clouddn.com/high-xunhuan.swig打开这个地址，复制全部内容，在你本地新建high.swig 文件。打开\\themes\\next\\layout_macro\\sidebar.swig文件，打开，在1234&lt;a href=&quot;&#123;&#123; url_for(theme.rss) &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;alternate&quot;&gt; &lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt; RSS&lt;/a&gt;后边加入：1&#123;% include &apos;high.swig&apos; %&#125;如：123456789&#123;% if theme.rss %&#125; &lt;div class=&quot;feed-link motion-element&quot;&gt; &lt;a href=&quot;&#123;&#123; url_for(theme.rss) &#125;&#125;&quot; rel=&quot;alternate&quot;&gt; &lt;i class=&quot;fa fa-rss&quot;&gt;&lt;/i&gt; RSS &lt;/a&gt; &#123;% include &apos;high.swig&apos; %&#125; &lt;/div&gt; &#123;% endif %&#125;接着在主题配置文件 _config.yml ，加入：12highqilai: enabled: true然后打开自定义CSS： \\themes\\next\\source\\css\\_custom\\custom.styl 加入1.feed-link a&#123;display: inline-block;&#125;保存，hexo clean ， hexo g , hexo s 查看效果！主页 High 起来，摇动。改动方法！themes\\next\\layout\\_layout.swig前添加：1&lt;link href=&quot;http://7u2ss1.com1.z0.glb.clouddn.com/harlem-shake-style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;地址改为你自己的CSS。失效了不怪！如果只是想当播放器听歌的话改 high.swig 文件内容为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;a title=&quot;收藏到书签，偶尔High一下^_^&quot; rel=&quot;alternate&quot; class=&quot;mw-harlem_shake_slow wobble shake&quot; href=&apos;javascript:( /* * Copyright (C) 2015 Rocko (rocko.xyz) &lt;rocko.zxp@gmail.com&gt; * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ function go() &#123; var songs = [ &quot;http://7u2ss1.com1.z0.glb.clouddn.com/%E9%AB%98%E6%A2%A8%E5%BA%B7%E6%B2%BB%20-%20%E5%AD%A4%E7%8B%AC.mp3&quot;, &quot;http://7u2ss1.com1.z0.glb.clouddn.com/one%20by%20one.mp3&quot;, &quot;http://7u2ss1.com1.z0.glb.clouddn.com/Enya%20-%20Only%20Time.mp3&quot;, &quot;http://7u2ss1.com1.z0.glb.clouddn.com/Enya%20-%20May%20It%20Be.mp3&quot;, &quot;......&quot; ]; function S() &#123; var e = document.getElementById(&quot;audio_element_id&quot;); if(e != null)&#123; var index = parseInt(e.getAttribute(&quot;curSongIndex&quot;)); if(index &gt; songs.length - 2) &#123; index = 0; &#125; else &#123; index++; &#125; e.setAttribute(&quot;curSongIndex&quot;, index); &#125; e.src = i; e.play() &#125; function initAudioEle() &#123; var e = document.getElementById(&quot;audio_element_id&quot;); if(e === null)&#123; e = document.createElement(&quot;audio&quot;); e.setAttribute(&quot;curSongIndex&quot;, 0); e.id = &quot;audio_element_id&quot;; e.loop = false; e.bgcolor = 0; e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;; document.body.appendChild(e); e.addEventListener(&quot;ended&quot;, function() &#123; go(); &#125;, true); &#125; &#125; initAudioEle(); var curSongIndex = parseInt(document.getElementById(&quot;audio_element_id&quot;).getAttribute(&quot;curSongIndex&quot;)); var i = songs[curSongIndex]; S(); &#125;)()&apos;&gt; &lt;i class=&quot;fa fa-music&quot;&gt;&lt;/i&gt; 听音乐&lt;/a&gt; 作者头像变成圆形打开自定义CSS： \\themes\\next\\source\\css\\_custom\\custom.styl 加入1234567.site-author-image &#123; border-radius: 100%; padding: 2px; border: 2px dashed #fff; animation: cycle 2s 0.5s forwards; transition: border-radius 2s;&#125;博主名字号大小,也在 custom.styl 文件:123.site-author-name &#123; font-size: 16px;&#125; 动态title改动先看代码如下：1234567891011121314151617&lt;!--崩溃欺骗--&gt;var OriginTitile = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos;╭(°A°`)╮ 页面崩溃&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&apos; + OriginTitile; titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125; &#125;);做为JS引用时，可以直接将上面代码保存为XXX.js，然后引用。在 \\themes\\next\\layout\\_layout.swig 最下边引用加入：12&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/duoshuoshuo.js&quot;&gt;&lt;/script&gt; hexo站点添加sitemap网站地图 安装hexo的sitemap网站地图生成插件进入 hexo 根目录，打开 git12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在你的hexo站点的_config.yml添加下面的代码，注意缩进格式！12345# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 配置成功后hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml其中sitemap.xml适合提交给谷歌搜素引擎，baidusitemap.xml适合提交百度搜索引擎。其次，在robots.txt中添加下面的一段代码：12Sitemap: http://你的域名/sitemap.xmlSitemap: http://你的域名/baidusitemap.xml请自行改成自己的网站。 给 Github 添加 README默认情况下， Github 中每一个项目，我们希望有一份 README.md 的文件来作为项目的说明，但是我们在项目根目录下的 blog\\source 目录下创建一份 README.md 文件，写好说明介绍，部署的时候，这个 README.md 会被 hexo 解析掉，而不会被解析到 Github 中去的。正确的解决方法其实很简单：把 README.md 文件的后缀名改成 MDOWN 然后扔到 blog/source 文件夹下即可，这样 hexo 不会解析， Github 也会将其作为MD文件解析。 代码块自定义样式``内的打开自定义CSS： \\themes\\next\\source\\css\\_custom\\custom.styl 加入123456789101112131415// 代码块自定义样式``内的code &#123; color: #fc6423; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 博客部署的message\\node_modules\\hexo-deployer-git\\lib\\deployer.js 文件末尾找到这一句：1Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;.改得个性化一点：1这个勤奋的家伙又更新了: &#123;&#123; now(\\&apos;YYYY-MM-DD HH:mm:ss\\&apos;) &#125;&#125;. 博文置顶 修改 hexo-generator-index 插件替换文件：node_modules/hexo-generator-index/lib/generator.js为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 设置文章置顶在文章 Front-matter 中添加 top 值，数值越大文章越靠前，如：1234567---title: Hexodate: tags: categories: top: 10--- NexT主题自定义无序列表样式打开自定义CSS： \\themes\\next\\source\\css\\_custom\\custom.styl 加入：123ul &#123;list-style-type: circle; // 空心圆，实心圆为 disc&#125;原文链接部分内容来自以下博客：务虚笔记小桥流水人家Jing’s BlogDoublemine岁月如歌胡闹的日子Never_yu’s Blog","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jimmy9876.top/tags/hexo/"}]},{"title":"用vue.js开发一个TodoList(3)","slug":"用vue-js开发一个TodoList-3","date":"2017-05-29T12:55:16.000Z","updated":"2017-10-16T07:16:33.213Z","comments":true,"path":"2017/05/29/用vue-js开发一个TodoList-3/","link":"","permalink":"http://jimmy9876.top/2017/05/29/用vue-js开发一个TodoList-3/","excerpt":"","text":"前两次开发的没有加入存储功能，一刷新页面，todolist也会随之消失为了让todolist刷新页面仍然存在于页面中，这里用到localstorage。下面是代码:文件Hello.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1 v-html=&quot;title&quot;&gt;&lt;/h1&gt; &lt;input v-model=&quot;newItem&quot; v-on:keyup.enter=&quot;addNew&quot;&gt;&lt;/input&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;&#123;finished:item.isFinished&#125;&quot; v-on:click=&quot;toggleFinish(item)&quot;&gt;&#123;&#123;item.label&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Store from &apos;./store&apos;export default &#123; data: function () &#123; return &#123; title: &apos;This Is A Todolist&apos;, items: Store.fetch(), newItem: &apos;&apos; &#125; &#125;, watch: &#123; items: &#123; handler: function (items) &#123; Store.save(items) &#125;, deep: true &#125; &#125;, methods: &#123; toggleFinish: function (item) &#123; item.isFinished = !item.isFinished &#125;, addNew: function () &#123; this.items.push(&#123; label: this.newItem, isFinished: false &#125;) this.newItem = &apos;&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.finished &#123; text-decoration: underline;&#125;li &#123; list-style: none; font-size: 1.6em; margin-top: 10px;&#125;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;input &#123; width: 230px; height: 40px; border-radius: 20px; padding: 0.4em 0.35em; border: 3px solid #CFCFCF; font-size: 1.55em;&#125;&lt;/style&gt;文件store.js123456789const STORAGE_KEY = 'todos-vuejs'export default &#123; fetch: function () &#123; return JSON.parse(window.localStorage.getItem(STORAGE_KEY) || '[]') &#125;, save: function (items) &#123; window.localStorage.setItem(STORAGE_KEY, JSON.stringify(items)) &#125;&#125;两个方法：一个设置，一个获取，将两个方法加入到Hello.vue中去,代码已放到github欢迎持续关注，如有问题欢迎留言交流","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://jimmy9876.top/tags/vue-js/"}]},{"title":"用vue.js开发一个TodoList(2)","slug":"用vue-js开发一个TodoList-2","date":"2017-05-29T04:43:54.000Z","updated":"2017-10-16T07:16:33.213Z","comments":true,"path":"2017/05/29/用vue-js开发一个TodoList-2/","link":"","permalink":"http://jimmy9876.top/2017/05/29/用vue-js开发一个TodoList-2/","excerpt":"","text":"上次搭建完了环境，这次开始学习如何写一个TodoList。首先打开文件Hello.vue打开之后，删除&lt;template&gt; ,&lt;script&gt; 内的与HelloWorld相关的代码。之后，在文件中写入代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1 v-text=&quot;title&quot;&gt;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;&#123;finished: item.isFinished&#125;&quot; v-on:click=&quot;toggleFinish(item)&quot;&gt; &#123;&#123; item.label &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; title: &apos;This is a todolist.&apos;, items: [ &#123; label: &apos;coding&apos;, isFinished: false &#125;, &#123; label: &apos;walking&apos;, isFinished: true &#125; ], liClass: &apos;ThisisliClass&apos; &#125; &#125;, methods: &#123; toggleFinish: function (item) &#123; item.isFinished = !item.isFinished &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;.finished&#123; text-decoration: underline;&#125;h1, h2 &#123; font-weight: normal;&#125;ul &#123; list-style-type: none; padding: 0;&#125;li &#123; display: inline-block; margin: 0 10px;&#125;a &#123; color: #42b983;&#125;&lt;/style&gt;其中123&lt;li v-for=&quot;item in items&quot; v-bind:class=&quot;&#123;finished: item.isFinished&#125;&quot; v-on:click=&quot;toggleFinish(item)&quot;&gt; &#123;&#123; item.label &#125;&#125; &lt;/li&gt;vue-for用来渲染items里面的内容，items是一个数组，用来存放待完成的任务以及是否完成，里面的vue-on是绑定事件，绑定了一个click事件，点击即触发，触发的方法是method里面的function，这个function实现了点击去除下划线的功能。接下来使用v-model实现一个双向绑定，构建一个input输入框，实现输入按回车就能将数据存放到数组里展示到页面上1234567891011121314151617181920212223242526 &lt;input v-model=&quot;newItem&quot; @keyup.enter=&quot;addNew&quot;&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; title: &apos;This is a todolist.&apos;, items: [ ], newItem: &apos;&apos; &#125; &#125;, methods: &#123; toggleFinish: function (item) &#123; item.isFinished = !item.isFinished &#125;, addNew: function () &#123; this.items.push(&#123; label: this.newItem, isFinished: false &#125;) this.newItem = &apos;&apos; &#125; &#125;&#125;&lt;/script&gt;具体项目源码已上传至github至此实现了一个简单的todolist。 未完待续…","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://jimmy9876.top/tags/vue-js/"}]},{"title":"git养成记之二","slug":"git养成记之二","date":"2017-05-27T05:03:09.000Z","updated":"2017-10-16T07:16:33.211Z","comments":true,"path":"2017/05/27/git养成记之二/","link":"","permalink":"http://jimmy9876.top/2017/05/27/git养成记之二/","excerpt":"","text":"前几天发现，-f是force强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容，所以说git push -f是一个比较可怕的命令，和rm -rf一样可怕😨 但是如果你不强推，可能就出现了这样的错误error:failed to push some refs to …当要push代码到git时，出现提示：12345678910111213141516171819error:failed to push some refs to ...Dealing with “non-fast-forward” errorsFrom time to time you may encounter this error while pushing:$ git push origin master To ../remote/ ! [rejected] master -&gt; master (non-fast forward) error: failed to push some refs to '../remote/' To prevent you from losing history, non-fast-forward updates were rejectedMerge the remote changes before pushing again. See the 'non-fast forward'section of 'git push --help' for details.问题（Non-fast-forward）的出现原因在于：git仓库中已经有一部分代码，所以它不允许你直接把你的代码覆盖上去。强推是解决办法之一，不过强推会覆盖之前的东西。。。至于覆盖了能不能找回，我还没有具体研究。另外还有一个办法，先把git的东西fetch到你本地然后merge后再push。12git fetchgit merge这2句命令等价于1git pull可是，这时候又出现了如下的问题：上面出现的 [branch “master”]是需要明确(.git/config)如下的内容123456[branch \"master\"] remote = origin merge = refs/heads/master这等于告诉git2件事:1，当你处于master branch, 默认的remote就是origin。2，当你在master branch上使用git pull时，没有指定remote和branch，那么git就会采用默认的remote（也就是origin）来merge在master branch上所有的改变如果不想或者不会编辑config文件的话，可以输入如下命令行：123$ git config branch.master.remote origin $ git config branch.master.merge refs/heads/master之后再重新git pull下。最后git push你的代码吧。总结：你的本地代码和远程仓库有冲突的时候，就会提示以上错误，说白了你就是要解决这些冲突，这样才能push到远程仓库当中去。如有疑问，欢迎留言交流。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://jimmy9876.top/tags/git/"}]},{"title":"用vue.js开发一个TodoList(1)","slug":"用vue-js开发一个TodoList-1","date":"2017-05-27T04:26:09.000Z","updated":"2017-10-16T07:16:33.213Z","comments":true,"path":"2017/05/27/用vue-js开发一个TodoList-1/","link":"","permalink":"http://jimmy9876.top/2017/05/27/用vue-js开发一个TodoList-1/","excerpt":"","text":"这几天，开始静下心来学习下vue.js，准备用vue.js开发一个TodoList，在学习的过程中把学习进度实时记录下来 介绍Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 安装 兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 Vue.js 支持所有兼容 ECMAScript 5 的浏览器。Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目，运行如下命令安装:1234567# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack 你的项目名# 安装依赖，走你$ cd 你的项目名$ npm install在这里，如果显示npm命令command not found请安装一下node.js如果觉得运行npm install慢，请打开终端运行如下界面，让npm走淘宝镜像。1$ npm install -g cnpm --registry=https://registry.npm.taobao.org之后凡遇到npm命令的时候换成cnpm代替，就会快很多。👉✨镜像网址✨👈安装成功运行1npm run dev浏览器出现如下页面至此就安装成功了，接下来可以一步一步开发一个TodoList项目了。项目实时更新于我的GitHub","categories":[],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://jimmy9876.top/tags/vue-js/"}]},{"title":"php模拟登陆实现课表抓取(最新版)","slug":"php模拟登陆实现课表抓取-最新版","date":"2017-05-26T07:13:01.000Z","updated":"2017-10-16T07:16:33.212Z","comments":true,"path":"2017/05/26/php模拟登陆实现课表抓取-最新版/","link":"","permalink":"http://jimmy9876.top/2017/05/26/php模拟登陆实现课表抓取-最新版/","excerpt":"","text":"首先，简单的说下表单原理，当我们在正方输入学号、密码、验证码的时候，点击提交按钮会产生一个POST请求，服务器在接受到POST请求以后，检查提交的学号密码验证码是否正确，正确则登陆成功。环境：Mac+MAMP Pro+phpstorm(PHP7.1)+Chrome 1、抓包打开谷歌浏览器访问学校教务处网址，打开开发者工具选择network，之后在正方里填上你的学号，密码，验证码，登录，看看这期间提交的数据。我们要用到的数据只有default2.aspx和xs_main.aspx?xh=”你的学号”这两个，其余的都是修饰用的css文件。点开default2.aspx可以看到你提交的表单数据。其中__VIEWSTATE是asp.net服务器的状态信息，需要抓取出来。另外default2.aspx这个页面采用了302跳转，即登录成功后会跳转到xs_main.aspx?xh=”你的学号”这个网址，这一点可能是大多数人模拟登录失败的原因。 2、构造登录页面三项信息必填，学号、密码、验证码。先说说验证码怎么保存到本地。验证码是由一个叫checkcode.aspx的网页生成的，要保存可以用fwrite来实现。直接用&lt;img src=&quot;&quot;填上刚才的网址理论上也可以，只要你能保存下这张图片所对应的cookie，这个cookie决定了你是否能够进行后续数据抓取。具体代码如下：首先要新建一个cookie文件夹，并且把session打开（可以解决高并发访问时登陆失败的问题）。12345&lt;?php session_start(); $id=session_id(); $_SESSION['id']=$id;?&gt;验证码保存：这里注意⚠️要自己新建一个cookie文件夹📁在你的项目目录。1234567891011121314&lt;?php $cookie = dirname(__FILE__) . '/cookie/'.$_SESSION['id'].'.txt'; //cookie路径 $verify_code_url = \"http://你的正方网址/CheckCode.aspx\"; //验证码地址 $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $verify_code_url); curl_setopt($curl, CURLOPT_COOKIEJAR, $cookie); //保存cookie curl_setopt($curl, CURLOPT_HEADER, 0); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $img = curl_exec($curl); //执行curl curl_close($curl); $fp = fopen(\"verifyCode.jpg\",\"w\"); //文件名 fwrite($fp,$img); //写入文件 fclose($fp);?&gt;之后构造input表单，设置好name123456&lt;form name=\"form1\" method=\"post\" action=\"kebiao.php\" &gt; 用户名:&lt;input type=\"text\" name=\"xh\" /&gt;&lt;!--普通文本框--&gt; 密码:&lt;input type=\"password\" name=\"pw\" /&gt;&lt;!--密码框--&gt; 验证码:&lt;input type=\"text\" name=\"code\" /&gt;&lt;img src=\"verifyCode.jpg\"&gt; &lt;input type=\"submit\" value=\"提交信息\" /&gt;&lt;/form&gt; 3、后端模拟登录页面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?php/** * Created by PhpStorm. * User: Apple * Date: 2019/5/17 * Time: PM9:08 */session_start();header(\"Content-type: text/html; charset=gb2312\"); //视学校而定，博主学校是gbk编码，php也采用的gbk编码方式//将表格转换成数组函数function get_td_array($table) &#123; $table = preg_replace(\"'&lt;table[^&gt;]*?&gt;'si\",\"\",$table); $table = preg_replace(\"'&lt;tr[^&gt;]*?&gt;'si\",\"\",$table); $table = preg_replace(\"'&lt;td[^&gt;]*?&gt;'si\",\"\",$table); $table = str_replace(\"&lt;/tr&gt;\",\"&#123;tr&#125;\",$table); $table = str_replace(\"&lt;/td&gt;\",\"&#123;td&#125;\",$table); //去掉 HTML 标记 $table = preg_replace(\"'&lt;[/!]*?[^&lt;&gt;]*?&gt;'si\",\"\",$table); //去掉空白字符 $table = preg_replace(\"'([rn])[s]+'\",\"\",$table); $table = preg_replace('/&amp;nbsp;/',\"\",$table); $table = str_replace(\" \",\"\",$table); $table = str_replace(\" \",\"\",$table); $table = explode('&#123;tr&#125;', $table); array_pop($table); foreach ($table as $key=&gt;$tr) &#123; $td = explode('&#123;td&#125;', $tr); array_pop($td); $td_array[] = $td; &#125; return $td_array;&#125;function login_post($url, $cookie, $post)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); //不自动输出数据，要echo才行 curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); //重要，抓取跳转后数据 curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie); curl_setopt($ch, CURLOPT_REFERER, 'http://202.119.225.34/'); //重要，302跳转需要referer，可以在Request Headers找到 curl_setopt($ch, CURLOPT_POSTFIELDS, $post); //post提交数据 $result = curl_exec($ch);// $content = curl_getinfo($ch);// echo json_encode($content); curl_close($ch); return $result;&#125;$_SESSION['xh'] = $_POST['xh'];$xh = $_POST['xh'];$pw = $_POST['pw'];$code = $_POST['code'];$cookie = dirname(__FILE__) . '/cookie/' . $_SESSION['id'] . '.txt';$url = \"http://202.119.225.34/default2.aspx\";$con1=login_post($url,$cookie,''); preg_match_all('/&lt;input type=\"hidden\" name=\"__VIEWSTATE\" value=\"([^&lt;&gt;]+)\" \\/&gt;/', $con1, $view); //获取__VIEWSTATE字段并存到$view数组中 $post=array( '__VIEWSTATE'=&gt;$view[1][0], 'txtUserName'=&gt;$xh, 'TextBox2'=&gt;$pw, 'txtSecretCode'=&gt;$code, 'RadioButtonList1'=&gt;'%D1%A7%C9%FA', //“学生”的gbk编码 'Button1'=&gt;'', 'lbLanguage'=&gt;'', 'hidPdrs'=&gt;'', 'hidsc'=&gt;'' ); $con2=login_post($url,$cookie,http_build_query($post)); //将数组连接成字符串 preg_match_all('/&lt;span id=\"xhxm\"&gt;([^&lt;&gt;]+)/', $con2, $xm); $xm[1][0] = substr($xm[1][0], 0, -4);$url2 = \"http://202.119.225.34/xskbcx.aspx?xh=\" . $_SESSION['xh'] . \"&amp;xm=\" . $xm[1][0];$con3 = login_post($url2, $cookie, '');//echo $con3;print_r($con3);?&gt;如果代码都正确，你将看到如下页面课表成功拿到。同理可以用正则表达式拿到成绩等，可以用这些数据做个微信公众号用来查询成绩课表等等。这些以后有时间再深入了解。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://jimmy9876.top/tags/php/"}]},{"title":"正方自动测评javascript脚本","slug":"hello-world","date":"2017-05-26T07:13:01.000Z","updated":"2017-10-16T07:16:33.211Z","comments":true,"path":"2017/05/26/hello-world/","link":"","permalink":"http://jimmy9876.top/2017/05/26/hello-world/","excerpt":"","text":"又是一年期末季，除了麻烦的期末考试还有没用的教学评价。教学评价太麻烦，就搞了个脚本来节省工作。这是直接打最高分给老师的，除了一个较好，其他都是好。如果你需要给差评，点完脚本后自己改一下。脚本是是用js写的，拖动下边的链接到书签栏就行了，或者直接添加书签。点击一次可以给一个老师完成评价，所有评价结束以后自己提交。拖动我：教学评价助手拖动我：教师评价助手截图：其他学校要用只要修改一下赋值就行。自己查看一下网页元素，然后看一下你们学校的赋值是什么？好? 良好？自己再改一下书签就行了。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jimmy9876.top/tags/javascript/"}]},{"title":"hexo+next搭建博客相册教程","slug":"hexo-next搭建博客相册教程","date":"2017-05-26T06:59:14.000Z","updated":"2017-10-16T07:16:33.211Z","comments":true,"path":"2017/05/26/hexo-next搭建博客相册教程/","link":"","permalink":"http://jimmy9876.top/2017/05/26/hexo-next搭建博客相册教程/","excerpt":"","text":"1.在git上输入hexo new page “photos”,创建photos页面，之后在sourse文件夹下能够找到photos文件夹，在index.md里添加type: photos.2.进入theme里的next下的config,在menu菜单下添加上photos页。3.如果语言选择是zh-hans的话，记得在languanges里把photos添加进去，以确保网页显示的菜单为photos.4.下面是重点，所有新建页面都可以照葫芦画瓢，next主题的整个网页布局都存在layout文件夹下，可以找到layout文件夹下有layout.swig和page.swig两个文件，layout.swig写的是整个页面的整体布局，page.swig是针对不同页面的布局。如果我们想搭建相册页，可以把自己写的相册页的代码放到page.swig,page.swig文件里div为post里有队不同页面的不同布局有分类，我们可以1&#123;% if page.type === “photos” %&#125;,将相册页的代码显示在这里面，用到的js和css别忘了引用，存的时候用绝对路径就可以了。还有一种方法就是把代码直接放到photos文件夹下的index.md里，但是这个方法的js和css布局容易出问题，两种方法，相册页存储的div不同，容易引起页面混乱。","categories":[],"tags":[{"name":"hexo_blog","slug":"hexo-blog","permalink":"http://jimmy9876.top/tags/hexo-blog/"}]},{"title":"Mac安装Hadoop2.8.0","slug":"Mac安装Hadoop2-8-0","date":"2017-05-25T12:38:50.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/05/25/Mac安装Hadoop2-8-0/","link":"","permalink":"http://jimmy9876.top/2017/05/25/Mac安装Hadoop2-8-0/","excerpt":"","text":"前几天试了一下Hadoop，搜了大量网络资料，现在发现有的网络资料太旧了，今天重新写了个，比较简单。#安装及配置Hadoop##1.首先安装一下Hadoop1brew install Hadoop##2.配置Hadoop目录下的文件###1.core-site.xml文件1&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt;###2.hdfs-site.xml1&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt;###3.mapred-site.xml1&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt;mapred-site.xml文件不存在，需要自己创建（可以复制一下mapred-site.xml.template文件再进行修改）###4.yarn-site.xml123456&lt;configuration&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;#2.运行Hadoop##1.进入Hadoop的目录，以mac系统为例目录为1/usr/local/Cellar/hadoop/2.8.0/libexec然后格式化文件系统:1$ bin/hdfs namenode -format##2.启动所有进程1sbin/start-all.sh期间输入无数次密码，在此可以设置一下ssh免密码登录。##3.访问localhost:50070和localhost:8088测试是否正常。","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://jimmy9876.top/tags/Hadoop/"}]},{"title":"阿里云配置nodejs+mongodb环境","slug":"阿里云配置nodejs-mongodb环境","date":"2017-05-25T10:00:37.000Z","updated":"2017-10-16T07:16:33.215Z","comments":true,"path":"2017/05/25/阿里云配置nodejs-mongodb环境/","link":"","permalink":"http://jimmy9876.top/2017/05/25/阿里云配置nodejs-mongodb环境/","excerpt":"","text":"阿里云系统：ubuntu14.04首先，在阿里云上安装nodejs，我一开始直接在线安装，发现真的是奇慢无比，于是在这里改用源码安装。。。##1.首先，我们去nodejs官网，下载指定版本的压缩包下载完成后，1scp -r 你的压缩包名字 root@你的公网ip然后ssh登录你的阿里云，解压文件并安装123456789101112 tar xvf 压缩包文件名 cd 文件名 ./configure make make install cp /usr/local/bin/node /usr/sbin/ 查看当前安装的Node的版本 node -v npm -vv.....这样，就安装完了，在make编译的时候要等大概20分钟，喝杯茶先（- -）##2.我们来下载mongodb不得不吐槽一下，直接下也是奇慢无比。。。。速度只有?b/s你敢信？等到猴年马月，于是我决定替换一下镜像源= =操作过程:###1、添加 MongoDB 公共GPG钥匙。1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927###2、创建列表文件(并替换国内镜像源)1echo &quot;deb http://mirrors.aliyun.com/mongodb/apt/ubuntu xenial/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list###3、重新加载本地包数据库1sudo apt-get update###4、安装MongoDB1sudo apt-get install -y mongodb-org###5、启动MongoDB1sudo service mongod start###6、打开MongoDB1sudo mongo注意，这里运行mongod可能会报错/data/db not found要在/目录下创建相应文件夹##3.如果你想卸载mongodb123451.sudo apt-get remove mongodb2.sudo apt-get remove --auto-remove mongodb3.sudo apt-get purge --auto-remove mongodb","categories":[],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://jimmy9876.top/tags/node-js/"}]},{"title":"阿里云ECS部署：nginx+MySQL+Laravel+PHP7+Redis+Node.js","slug":"阿里云-ECS-部署：nginx-MySQL-Laravel-PHP7-Redis-Node-js","date":"2017-05-25T09:59:11.000Z","updated":"2017-10-16T07:16:33.214Z","comments":true,"path":"2017/05/25/阿里云-ECS-部署：nginx-MySQL-Laravel-PHP7-Redis-Node-js/","link":"","permalink":"http://jimmy9876.top/2017/05/25/阿里云-ECS-部署：nginx-MySQL-Laravel-PHP7-Redis-Node-js/","excerpt":"","text":"版本：ubuntu 14.04（64位） 1.安装Nginx（version：1.9） 1、首先添加nginx_signing.key123wget http://nginx.org/keys/nginx_signing.keysudo apt-key add nginx_signing.key 2、添加Nginx官方提供的源123echo &quot;deb http://nginx.org/packages/mainline/ubuntu/ trusty nginx&quot;&gt;&gt; /etc/apt/sources.listecho &quot;deb-src http://nginx.org/packages/mainline/ubuntu/ trusty nginx&quot;&gt;&gt; /etc/apt/sources.list 3、更新源并安装Nginx123sudo apt-get updatesudo apt-get install nginx 4、Nginx配置打开配置文件。1vim /etc/nginx/nginx.conf修改user：1user www-data;增加server：1234567891011121314151617181920212223242526272829303132333435server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /var/www/laravel/public; index index.php index.html index.htm; server_name server_domain_or_IP; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125;注意：root中的laravel应为你的项目名称，server_name应为你的服务器公网IP。配置完之后重启Nginx，使上面的配置项生效。1sudo service nginx restart 2.安装PHP（version：7.0x） 1、添加PPA，添加过程中需要按一次回车（Enter）键12345sudo apt-get install python-software-properties software-properties-commonsudo add-apt-repository ppa:ondrej/phpsudo apt-get update 2、安装PHP7以及所需的一些扩展1sudo apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mcrypt php7.0-mbstring php7.0-dom php7.0-gd 3、配置PHP7打开php.ini配置文件:1sudo vim /etc/php/7.0/fpm/php.ini找到cgi.fix_pathinfo选项，去掉注释;，然后将值设置为0 （这个操作是为了避免PHP7的一个漏洞，PS：vim使用“/”进入查找模式）1cgi.fix_pathinfo=0启用php7.0-mcrypt1sudo phpenmod mcrypt重启php7.0-fpm1sudo service php7.0-fpm restart 3.安装Mysql（version：5.6）1sudo apt-get install mysql-server-5.6 mysql-client-5.6途中会提示设置MySQL的密码，安装好后：1mysql -uroot -p然后输入刚刚设置的密码，能成功进入即成功安装。 4.安装Laravel（version：latest） 1、安装composer，分别执行以下语句1234567sudo apt-get install curlcd ~curl -sS https://getcomposer.org/installer| phpsudo mv composer.phar /usr/local/bin/composer 2、安装压缩、解压缩程序1sudo apt-get install zip unzip 3、安装git1sudo apt-get install git然后在Coding上创建一个私有项目laravel，里面包含所有该Laravel项目所需代码。 4、使用git将代码clone到服务器上1234567cd /varmkdir wwwcd wwwgit clone your-project-git-link注意：git clone 的地址应是你自己Coding仓库中的项目SSL链接地址 5、修改laravel项目的访问权限123sudo chown -R :www-data /var/www/laravelsudo chmod -R 775 /var/www/laravel/storage 6、导入laravel 的vendor目录123cd /var/www/laravelcomposer install注意：5，6两部操作中的“laravel” 应该是你自己项目的的名称。 5.安装Redis（version：3.0.7）最新版地址：http://redis.io/download12345cd ~wget http://download.redis.io/releases/redis-3.0.7.tar.gztar xzf redis-3.0.7.tar.gz配置并启动Redis123cd redis-3.0.7vi redis.conf搜索bind，将# bind 127.0.0.1的注释去掉后保存（这样做后只有本地服务可以访问Redis，不然就有安全隐患）123makesrc/redis-server看到redis的运行提示即完成。 6.安装nodeJS添加下面链接中的源，然后安装1https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions 番外：安装ZSH shell1234567github：sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;sudo apt-get install zshchsh -s $(which zsh)sh -c&quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 如果已经下了5.0想升级成7.0的朋友可执行以下代码sudo apt-get install python-software-properties software-properties-common sudo LC_ALL=C.UTF-8 add-apt-repository ppa:ondrej/php sudo apt-get update 把之前的PHP5.0remove掉sudo apt-get remove php5-common -y sudo apt-get purge php5-common -y 安装现在的7.0sudo apt-get install php7.0 php7.0-fpm php7.0-mysql -y sudo apt-get --purge autoremove -y","categories":[],"tags":[{"name":"阿里云ECS","slug":"阿里云ECS","permalink":"http://jimmy9876.top/tags/阿里云ECS/"}]},{"title":"Mac下重置mysql的root密码","slug":"Mac下重置mysql的root密码","date":"2017-05-25T09:57:05.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/05/25/Mac下重置mysql的root密码/","link":"","permalink":"http://jimmy9876.top/2017/05/25/Mac下重置mysql的root密码/","excerpt":"","text":"我的mysql版本 MYSQL V5.7.9，旧版本请使用：1UPDATE mysql.user SET Password=PASSWORD(&apos;新密码&apos;) WHERE User=&apos;root&apos;;###Mac OS X - 重置 MySQL Root密码密码太多记不住？？你是否忘记了Mac OS 的MySQL的root密码? 通过以下4步就可重新设置新密码：#####1. 停止 mysql server.通常是在 ‘系统偏好设置’ &gt; MySQL &gt; ‘Stop MySQL Server’#####2. 打开终端，输入：1sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables#####3. 打开另一个新终端，输入:1234567sudo /usr/local/mysql/bin/mysql -u root UPDATE mysql.user SET authentication_string=PASSWORD(&apos;你的新密码&apos;) WHERE User=&apos;root&apos;; FLUSH PRIVILEGES; exit#####4. 重启MySQL.好了，这样就完成了","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://jimmy9876.top/tags/mysql/"}]},{"title":"git养成记之一","slug":"gitbranch","date":"2017-05-25T08:56:45.000Z","updated":"2017-10-16T07:16:33.211Z","comments":true,"path":"2017/05/25/gitbranch/","link":"","permalink":"http://jimmy9876.top/2017/05/25/gitbranch/","excerpt":"","text":"今天，简单了解了一下关于git分支的用法场景：由于项目需要，我们团队进行开发，各个成员完成各自的功能模块，但是在git上上传的时候非常乱，这个时候，我们需要用到分支branch，当然这个功能只是分支的一部分功能，还有很多功能后续我会再进行深度学习了解。 1.首先找到团队的GitHub地址，把他克隆下来1git clone https://xxxxxx.xxxx/xxxx(你的项目地址)克隆完成之后，cd进入你的项目1cd 你的项目名称然后，你开始开发你的功能了 2.新建一个分支接下来，我们新建一个分支1git branch &lt;your branch name&gt;(你的分支名)然后，切换一下分支1git checkout &lt;your branch name&gt;(你的分支名)切换成功terminal输出如下1Switched to branch &lt;your branch name&gt;(你的分支名)我们git status一下，看一下改动的文件，红色的是你修改过的文件，然后执行git add -f，这时你再git status一下，是不是发现红色的文件都变成绿色了。然后运行1git commit -m \"你的注释/可以写写改了啥功能，或者就是什么版本啊balabala\"commit成功了控制台大概如下输出123[experiment e465517] branch 1 file changed, 1 insertion(+) create mode 100644 hello/hello最后，运行一下代码把你项目提交上去1git push origin &lt;your branch name&gt;(你的分支名)成功了大概terminal显示如下1234567Counting objects: 4, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (4/4), 311 bytes | 0 bytes/s, done.Total 4 (delta 1), reused 0 (delta 0)To https://git.coding.net/CodeTiger_/livec_news.git * [new branch] experiment -&gt; experiment至此，就全部完成了，如有疑问或者文章存在任何错误，欢迎指正😆370555337@qq.com","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://jimmy9876.top/tags/git/"}]},{"title":"Hexo教程","slug":"Hexo教程","date":"2017-05-25T05:00:17.000Z","updated":"2017-10-16T07:16:33.210Z","comments":true,"path":"2017/05/25/Hexo教程/","link":"","permalink":"http://jimmy9876.top/2017/05/25/Hexo教程/","excerpt":"","text":"hexo 新建一篇文章给它添加分类和标签:1hexo new \"Hexo教程\"通过mou编辑器打开：添加tags和categories:123456789---title: title #文章標題date: 2016-06-01 23:47:44 #文章生成時間categories: \"Hexo教程\" #文章分類目錄 可以省略tags: #文章標籤 可以省略 - 标签1 - 标签2 description: #你對本頁的描述 可以省略---","categories":[],"tags":[{"name":"hexo_blog","slug":"hexo-blog","permalink":"http://jimmy9876.top/tags/hexo-blog/"}]}]}